[ { "title": "springboot dto groups - validation created일때만 적용하기", "url": "/posts/springboot-dto-validation-groups/", "categories": "SPRINGBOOT", "tags": "springboot, jpa", "date": "2025-09-26 07:47:00 +0900", "snippet": "DTO를 Create, Update 공용으로 사용할때, Create일때만 validation 적용하기Interface file 생성CreateValidationGroup이라는 빈 인터페이스를 만들어준다.com.demo.microserviceㄴ validators ㄴ CreateValidationGroupDTO groups 지정해당 DTO Field Validation에 groups을 지정한다.@NotBlank(groups = CreateValidationGroup.class, message = &quot;Registered date is required&quot;) private String registerDate;Controller에 적용PUT에는 Default만 적용, POST에는 Default + CreateValidationGroup@PostMapping public ResponseEntity&amp;lt;ResponseDTO&amp;gt; create(@Validated({Default.class, CreateValidationGroup.class}) @RequestBody RequestDTO RequestDTO){ }" }, { "title": "springboot github action docker ec2 cicd", "url": "/posts/springboot-ec2-ci-cd/", "categories": "CICD", "tags": "cicd, github, docker", "date": "2025-09-23 04:40:00 +0900", "snippet": "DockerfileFROM openjdk:23WORKDIR /appCOPY target/demo-*.jar app.jarEXPOSE 8080ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;app.jar&quot;]main.ymlname: build teston: push: branches: - mainjobs: build: runs-on: ubuntu-latest steps: - name: Checkout code uses: actions/checkout@v3 - name: Set up JDK uses: actions/setup-java@v3 with: distribution: &#39;temurin&#39; java-version: 23 - name: Build with Maven run: mvn clean package -DskipTests - name: Docker build run: docker build -t $/javademo:latest . - name: Docker login uses: docker/login-action@v1 with: username: $ password: $ - name: Docker push run: docker push $/javademo:latest deploy: needs: build runs-on: ubuntu-latest steps: - name: Install SSH key uses: webfactory/ssh-agent@v0.9.0 with: ssh-private-key: $ - name: Deploy on EC2 run: | ssh -o StrictHostKeyChecking=no $@$ &amp;lt;&amp;lt; &#39;EOF&#39; sudo docker login -u $ -p $ sudo docker pull $/javademo:latest sudo docker stop javademo || true sudo docker rm javademo || true sudo docker run -d --name javademo -p 80:8080 $/javademo:latest EOF" }, { "title": "kafka basic", "url": "/posts/kafka-basic/", "categories": "KAFKA", "tags": "kafka", "date": "2025-09-16 04:40:00 +0900", "snippet": "Kafka - Event-Driven Architectures High Throughput Fault Tolerance Scalability Real-Time ProcessingTopicWhere all similar events related to a service can be stored. Message Categorization Immutable Log Multi-Consumer Access Decoupled Communication ReplicationBroker Message Management: Storing, retrieving, distributing messages Cluster Node: Each broker is a node in the Kafka cluster Scalability: Distributing data across nodes Fault Tolerance Dynamic Membership: Can join or leave clusters without downtimeHigh Availability of Kafka Using ReplicationDistributionDistributes a topic’s data across multiple brokers in a kafka clusterParallelismEnable parallel processing of messages by consumersScalabilityScale beyond the limitations of a single brokerFault ToleranceEnsuring data durabilityOrderingStricktly ordered, providing a clear sequence of eventsSerialization Json Apache Avro Protocol BuffersMurmur2 HashEnsures even distribution and per-key ordering within a topic’s partitionsDead Letter QueueA dead letter queue isolates poison pill messages, enabling analysis and resolution without disrupting the main processing flow.CLI Script// download Kafkawget https://archive.apache.org/dist/kafka/3.0.0/kafka_2.13-3.0.0.tgztar -xvf kafka_2.13-3.0.0.tgz// download Javasudo yum install java-1.8.0-amazon-corretto// Generate UUIDbin/kafka-storage.sh random-uuid// Format Storagebin/kafka-storage.sh format -t &amp;lt;your-uuid&amp;gt; -c config/kraft/server.properties// Edit Server Propertiesvim config/kraft/server.propertieslisteners=PLAINTEXT://0.0.0.0:9092controller.listeners=PLAINTEXT://0.0.0.0:9093advertised.listeners=PLAINTEXT://EC2-PRIVATE-IP:9092// Start Kafka Serverbin/kafka-server-start.sh config/kraft/server.properties// Create S3 Bucket &amp;amp;// Upload confluentinc-kafka-connect-s3-10.5.23.zip// Download and Extract Connector(EC2)aws s3 cp s3://&amp;lt;your_bucket_name&amp;gt;/confluentinc-kafka-connect-s3-10.5.23.zip .unzip confluentinc-kafka-connect-s3-10.5.23.zip// Edit Connect Standalone Propertiesvim kafka_2.13-3.0.0/config/connect-standalone.propertiesbootstrap.servers=&amp;lt;PRIVATE IP of EC2 instance&amp;gt;:9092plugin.path=The path where you downloaded the S3 connect(plugin.path=/home/ec2-user/confluentinc-kafka-connect-s3-10.5.23)// Create S3 Sink Connector Propertiesvim kafka_2.13-3.0.0/config/s3-sink-connector.properties----------name=s3-sink-connectorconnector.class=io.confluent.connect.s3.S3SinkConnectortasks.max=1topics=cartevents3.bucket.name=kafka-connect-s3-sink-example#Replace this with S3 bucket names3.region=us-east-1flush.size=5rotate.schedule.interval.ms=60000storage.class=io.confluent.connect.s3.storage.S3Storageformat.class=io.confluent.connect.s3.format.json.JsonFormatpartitioner.class=io.confluent.connect.storage.partitioner.DefaultPartitionertimezone=UTC# Converter settingskey.converter=org.apache.kafka.connect.json.JsonConvertervalue.converter=org.apache.kafka.connect.json.JsonConverterkey.converter.schemas.enable=falsevalue.converter.schemas.enable=falsebehavior.on.null.values=ignore----------// Start Kafka Connectbin/connect-standalone.sh config/connect-standalone.properties config/s3-sink-connector.properties" }, { "title": "react gitlab aws s3 ci/cd", "url": "/posts/gitlab-aws-s3-ci-cd/", "categories": "CICD", "tags": "react, s3, aws, cicd, gitlab", "date": "2025-09-13 04:40:00 +0900", "snippet": "Create a S3 bucket권한 모든 퍼블릭 액세스 차단 Disable 버킷 정책{ &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;Statement1&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: &quot;*&quot;, &quot;Action&quot;: &quot;s3:GetObject&quot;, &quot;Resource&quot;: &quot;arn:aws:s3:::ohtvitebucket/*&quot; } ]} Resource: arn + “/*”Create IAM User AmazonS3FullAccessGitlabSecret settingsProject -&amp;gt; Settings -&amp;gt; CI/CD -&amp;gt; Variables AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_DEFAULT_REGION S3_BUCKET.gitlab-ci.ymlstages: - build - deploybuild: stage: build image: node:23 script: - echo &quot;build started&quot; - npm install - npm run build artifacts: paths: - dist/deploy: stage: deploy image: name: amazon/aws-cli entrypoint: [&quot;&quot;] script: - aws --version build 산출물 dist를 artifacts 지정하여 deploy에서 사용" }, { "title": "ownership of rust(1)", "url": "/posts/ownership-of-rust(1)/", "categories": "RUST", "tags": "rust, ownership", "date": "2023-01-03 12:40:00 +0900", "snippet": "OwnershipOwnership이란 Rust만의 유니크한 특성이며, gc없이도 안전하게 메모리를 사용하게 해주는 개념이다.What is Ownership?Ownership은 Rust가 어떻게 memory를 관리할 지 통제하는 규칙들의 set이다.어떤 언어들은 garbage collection이 주기적으로 더이상 사용하지 않는 메모리들을 관리해주고(Java, JS, Python, GO)어떤 언어들은 프로그래머가 직접 할당과 해제를 하여 메모리를 관리해야 한다.(C, C++)Rust는 그 외의 방식: compiler가 체크하는 규칙들의 set인 ownership 시스템에 의해 관리된다. 규칙이 위배된다면, compile되지 않는다! The Stack and the Heap대부분의 언어들은 작업할 때 stack과 heap에 대해 신경쓰지 않아도 된다. 하지만 Rust는 value가 stack or heap 어디에 있는 값인지에 따라 다르게 작동한다. 따라서 여기서 간단하게 짚고 넘어가겠다.Stack Last in, First out (접시쌓기와 같다) data는 known, fixed size fastHeap Allocator가 heap에서 충분한 자리를 찾고 pointer을 return(Allocating: 레스토랑의 자리 안내와 같다) Compile시 unknown size =&amp;gt; Heap slow more workOwnership Rules다음의 규칙들은 기억하고 예제를 봅시다! Rust에서 각 Value는 owner가 있다. 한 번에 한 owner만 있을 수 있다. owner가 scope를 벗어나면 value는 drop된다.Variable Scopefn main() { { // s is not valid here, it’s not yet declared let s = &quot;hello&quot;; // s is valid from this point forward // do stuff with s } // this scope is now over, and s is no longer valid}이 코드에서 중요한 사실 두가지: scope 안에서 s는 valid하다. scope를 벗어나면 no longer valid하다.The String Type위의 예제는 string literals로 많은 상황에 맞지 않고, 변형불가능하다. 우리는 String을 사용하여 unknown한 값을 저장할 수 있다.let s = String::from(&quot;hello&quot;);변형 또한 가능하다.let mut s = String::from(&quot;hello&quot;);s.push_str(&quot;, world!&quot;); // push_str() appends a literal to a Stringprintln!(&quot;{}&quot;, s); // This will print `hello, world!`왜 String은 변형 가능하지만 literals는 불가능할까? 이는 두 타입의 메모리 저장 방식이 다르기 때문이다.Memory and Allocation변형가능하며 늘어날 수 있는 text를 위해서 우리는 heap에 메모리를 할당해야 한다. 이것은 곧 runtime에 allocator에 의해 메모리가 요청되어야 한다. 우리가 해당 String에 관하여 업무가 끝났을 때 이 메모리는 allocator에게 반환 되어야 한다.을 의미한다.첫번째 부분은 String::from 을 호출 함으로 해결된다. 두번째 부분이 쉽지않다. GC가 존재하지않으니 우리가 직접 메모리를 관리해야 한다. 너무 빨리 정리하면 invalid해지고, 두번 실행해도 bug이다. 우리는 딱 한번의 allocate와 딱 한번의 free로 매치해야 한다.변수가 해당 scope 밖으로 나가면 Rust는 ‘drop’이라는 함수를 call하여 메모리를 정리한다.Variables and Data interacting with Movelet s1 = String::from(&quot;hello&quot;);let s2 = s1;해당 코드는 s2에 s1의 value를 단순히 복사할 것 같지만 그렇지 않다. 왼쪽의 ptr, len, capacity의 정보들은 stack에 저장되고, 우측의 contents는 heap 메모리에 저장된다.s2에 s1을 할당할 때, contents가 아닌 해당 정보가 담긴 stack의 값만 복사된다.(아래의 사진)따라서 두개의 포인터가 같은 곳을 바라보고 있게 된다는 뜻인데, 앞서 말했듯 scope를 벗어나면 free 시킬 것이고 그렇다면 두개의 포인터 모두 같은 메모리에 대해 중복으로 처리를 시도하게 된다. 이는 한번 allocate - 한번 free를 위해된다.이러한 메모리 safety를 위해서 rust는 let s2 = s1 실행시 s1은 더이상 valid하지 않다고 여긴다.let s1 = String::from(&quot;hello&quot;);let s2 = s1;println!(&quot;{}, world!&quot;, s1); // Error!이는 다른 언어의 shallow copy, deep copy의 원리와 비슷하다. 또한 이 경우 우리는 s1에서 s2로 이동했다고 표현한다. (s1 invalid, scope 벗어날 시 s2는 memory free 실행)Variables and Data interacting with Clone위와는 달리 heap data까지 deep copy를 하고 싶으면 우리는 Clone을 사용할 수있다.let s1 = String::from(&quot;hello&quot;);let s2 = s1.clone();println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);Stack-Only Data: Copylet x = 5;let y = x;println!(&quot;x = {}, y = {}&quot;, x, y);다음과 같은 integer값은 clone 필요없이 잘 작동한다. integers 같은 값은 정해진 size이며 전체 값이 stack에 저장된다. 따라서 실제값을 copy하는 데에도 굉장히 빠르다.Rust는 ‘Copy’라는 special annotation을 갖고있는데, 만약 type이 Copy를 implements한다면 위 예제의 ‘이동’이 발생하지않고 평범하게 copy되고 할당 후에도 계속 valid하다.Copy를 implements하는 타입 목록은 다음과 같다. All the integer types. The Boolean type All the floating-point types The character type Tuples, if they only contain types that also implement Copy.(둘다 Copy를 implement하는 경우)Ownership and Functions함수에 값을 전달하는 것도 변수에 초기화 하는 것과 비슷하다. move or copy.fn main() { let s = String::from(&quot;hello&quot;); // s comes into scope takes_ownership(s); // s&#39;s value moves into the function... // ... and so is no longer valid here let x = 5; // x comes into scope makes_copy(x); // x would move into the function, // but i32 is Copy, so it&#39;s okay to still // use x afterward} // Here, x goes out of scope, then s. But because s&#39;s value was moved, nothing // special happens.fn takes_ownership(some_string: String) { // some_string comes into scope println!(&quot;{}&quot;, some_string);} // Here, some_string goes out of scope and `drop` is called. The backing // memory is freed.fn makes_copy(some_integer: i32) { // some_integer comes into scope println!(&quot;{}&quot;, some_integer);} // Here, some_integer goes out of scope. Nothing special happens.takes_ownership(s); 이후에 s를 호출하면 compile-time Error!Return Values and Scopefn main() { let s1 = gives_ownership(); // gives_ownership moves its return // value into s1 let s2 = String::from(&quot;hello&quot;); // s2 comes into scope let s3 = takes_and_gives_back(s2); // s2 is moved into // takes_and_gives_back, which also // moves its return value into s3} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing // happens. s1 goes out of scope and is dropped.fn gives_ownership() -&amp;gt; String { // gives_ownership will move its // return value into the function // that calls it let some_string = String::from(&quot;yours&quot;); // some_string comes into scope some_string // some_string is returned and // moves out to the calling // function}// This function takes a String and returns onefn takes_and_gives_back(a_string: String) -&amp;gt; String { // a_string comes into // scope a_string // a_string is returned and moves out to the calling function}함수를 사용하면서 소유권을 갖는 것과 반납하는 것은 매우 성가시다. Rust에서는 이를 위해서 references를 제공한다!Ref: https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" }, { "title": "atomic design 아토믹 디자인", "url": "/posts/atomicdesign/", "categories": "ETC", "tags": "design", "date": "2022-10-27 21:00:00 +0900", "snippet": "Atomic design아토믹 디자인이란 5단계로 구성되어 더욱 계획적/계층적으로 인터페이스를 만들어가는 방법론. Atomic design is a methodology composed of five distinct stages working together to create interface design systems in a more deliberate and hierarchical manner.Stages Atoms Molecules Organisms Templates PagesAtoms기본적인 HTML Elements들(labels, inputs, buttons, etc…)MoleculesUI elements들의 그룹으로서, 하나의 기능 동작 가능한 요소 molecules are relatively simple groups of UI elements functioning together as a unit. Input + Button = search formOrganismsmolecules과 atoms들로 구성된 하나의 유기체.(ex. nav bar) Organisms are relatively complex UI components composed of groups of molecules and/or atoms and/or other organisms.Templates뼈대가 완성된(contents만 빠진 skeleton layout)Pages완성된 페이지Instagram exampleexampleReferencesAtomic Design Methodology" }, { "title": "js generators", "url": "/posts/modern-js-tutorial-generators/", "categories": "JS", "tags": "javascript", "date": "2022-09-08 23:03:00 +0900", "snippet": "Generators제너레이터는 여러 개의 값을 필요에 따라 하나씩 반환할 수 있다.Generator funcfunction* generateSequence() { yield 1; yield 2; return 3;}let generator = generateSequence();generator // [Object Generator]let one = generator.next();one // {value: 1, done: false}let two = generator.next();two // {value: 2, done: false}let three = generator.next();three // {value: 3, done: true}let four = generator.next();four // {value: undefined, done: true}Iterablefunction* generateSequence() { yield 1; yield 2; yield 3;}let generator = generateSequence();for(let value of generator) { alert(value); // 1, 2, 3}let sequence = [0, ...generateSequence()];alert(sequence); // 0, 1, 2, 3 3이 yield가 아닌 return이면 1,2 까지만 출력됨.done:true면 마지막 value 무시됨ReferencesModern Javascript Tutorial" }, { "title": "js promise api", "url": "/posts/modern-js-tutorial-promise-api/", "categories": "JS", "tags": "javascript", "date": "2022-09-03 21:03:00 +0900", "snippet": "Promise.all여러 개의 promise를 동시에 실행하고 모든 promise를 기다림Promise.all([ new Promise(resolve =&amp;gt; setTimeout(() =&amp;gt; resolve(1), 3000)), // 1 new Promise(resolve =&amp;gt; setTimeout(() =&amp;gt; resolve(2), 2000)), // 2 new Promise(resolve =&amp;gt; setTimeout(() =&amp;gt; resolve(3), 1000)) // 3]).then(alert);// 3초뒤 1,2,3 Promise 하나라도 거부시 전체 Error 반환됨Promise.all([ new Promise((resolve, reject) =&amp;gt; setTimeout(() =&amp;gt; resolve(1), 1000)), new Promise((resolve, reject) =&amp;gt; setTimeout(() =&amp;gt; reject(new Error(&quot;에러 발생!&quot;)), 2000)), new Promise((resolve, reject) =&amp;gt; setTimeout(() =&amp;gt; resolve(3), 3000))]).catch(alert);// 2초뒤 Error: 에러 발생!Promise.allSettled모든 promise 기다리나, promise중 실패값이 있어도 다른 promise는 정상적으로 수행됨 응답 성공시 : {status:”fulfilled”, value:result} 응답 실패시 : {status:”rejected”, reason:error}let urls = [ &#39;https://api.github.com/users/iliakan&#39;, &#39;https://api.github.com/users/Violet-Bora-Lee&#39;, &#39;https://no-such-url&#39;];Promise.allSettled(urls.map(url =&amp;gt; fetch(url))) .then(results =&amp;gt; { // (*) results.forEach((result, num) =&amp;gt; { if (result.status == &quot;fulfilled&quot;) { alert(`${urls[num]}: ${result.value.status}`); } if (result.status == &quot;rejected&quot;) { alert(`${urls[num]}: ${result.reason}`); } }); });//[ {status: &#39;fulfilled&#39;, value: ...응답...}, {status: &#39;fulfilled&#39;, value: ...응답...}, {status: &#39;rejected&#39;, reason: ...에러 객체...}]폴리필if(!Promise.allSettled) { Promise.allSettled = function(promises) { return Promise.all(promises.map(p =&amp;gt; Promise.resolve(p).then(value =&amp;gt; ({ status: &#39;fulfilled&#39;, value }), reason =&amp;gt; ({ status: &#39;rejected&#39;, reason })))); };}Promise.racePromise.all과 비슷하나 먼저 처리되는 promise만 반환Promise.race([ new Promise((resolve, reject) =&amp;gt; setTimeout(() =&amp;gt; resolve(1), 1000)), new Promise((resolve, reject) =&amp;gt; setTimeout(() =&amp;gt; reject(new Error(&quot;에러 발생!&quot;)), 2000)), new Promise((resolve, reject) =&amp;gt; setTimeout(() =&amp;gt; resolve(3), 3000))]).then(alert); // 1ReferencesModern Javascript Tutorial" }, { "title": "modern js tutorial class", "url": "/posts/modern-js-tutorial-class/", "categories": "JS", "tags": "javascript", "date": "2022-08-24 00:45:00 +0900", "snippet": "기본문법class User { constructor(name) { this.name = name; } sayHi() { alert(this.name); }}let user = new User(&quot;John&quot;);user.sayHi(); class 또한 함수로 분류됨. 하지만 class로 생성한 함수엔 특수 내부 프로퍼티 ‘[[IsClassConstructor]]: true’ 클래스에 정의된 메서드는 non-enumerable strict mode 적용정적 메서드특정 클래스 인스턴스가 아닌 클래스 ‘전체’에 필요한 기능을 만들 때 사용class User { static staticMethod() { alert(this === User); }}User.staticMethod(); // trueReferencesModern Javascript Tutorial" }, { "title": "modern js tutorial prototype methods", "url": "/posts/modern-js-tutorial-prototype-methods/", "categories": "JS", "tags": "javascript", "date": "2022-08-22 00:45:00 +0900", "snippet": "prototype methodsObject.create(proto, [descriptors]) - [[Prototype]]이 proto를 참조하는 빈객체를 생성.Object.getPrototypeOf(obj) - obj의 [[Prototype]]을 반환.Object.setPrototypeOf(obj, proto) - obj의 [[Prototype]]이 proto가 되도록 설정.let animal = { eats: true};// 프로토타입이 animal인 새로운 객체를 생성.let rabbit = Object.create(animal, { jumps: { value: true }});rabbit.jumps // truerabbit.eats // trueObject.getPrototypeOf(rabbit) === animal); // trueObject.setPrototypeOf(rabbit, {}); // rabbit의 프로토타입을 {}으로 바꿈.모든 프로퍼티 복사let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));Simple Objectlet test1 = {};test1 // [[Prototype]]: Objectlet test2 = Object.create(null);test2 // No properties - 내장 메서드 없음ReferencesModern Javascript Tutorial" }, { "title": "modern js tutorial prototype native", "url": "/posts/modern-js-tutorial-prototype-native/", "categories": "JS", "tags": "javascript", "date": "2022-08-20 22:12:00 +0900", "snippet": "Object.prototype객체를 생성하면 [[Prototype]]은 Object.prototype을 참조한다.let obj = {};alert(obj.__proto__ === Object.prototype); // truealert(obj.toString === obj.__proto__.toString); //truealert(obj.toString === Object.prototype.toString); //true내장 객체 프로토타입배열 [1,2,3] 생성시 Array.prototype이 프로토타입이 되며, 배열 메서드 사용가능.Array, Function, Number는 Object.prototype을 상속체인 맨 위에는 nulllet arr = [1, 2, 3];alert( arr.__proto__ === Array.prototype ); // truealert( arr.__proto__.__proto__ === Object.prototype ); // truealert( arr.__proto__.__proto__.__proto__ ); // null메서드 빌리기let obj = { 0: &quot;Hello&quot;, 1: &quot;world!&quot;, length: 2,};obj.join = Array.prototype.join;alert( obj.join(&#39;,&#39;) ); // Hello,world!ReferencesModern Javascript Tutorial" }, { "title": "modern js tutorial prototype func property", "url": "/posts/modern-js-tutorial-prototype-func-property/", "categories": "JS", "tags": "javascript", "date": "2022-08-19 00:12:00 +0900", "snippet": "생성자 ‘함수’를 사용해 객체를 만든 경우let animal = { eats: true};function Rabbit(name) { this.name = name;}Rabbit.prototype = animal;let rabbit = new Rabbit(&quot;흰 토끼&quot;); // rabbit.__proto__ == animalalert( rabbit.eats ); // truefunc default propertyfunction Rabbit(){}Rabbit.prototype // {constructor: Rabbit()}let rabbit = new Rabbit();rabbit.constructor == Rabbit; //true -&amp;gt; [[Prototype]]을 거쳐 접근새로운 객체 생성function Rabbit(name) { this.name = name; alert(name);}let rabbit = new Rabbit(&quot;흰 토끼&quot;);let rabbit2 = new rabbit.constructor(&quot;검정 토끼&quot;);prototype 변경function Rabbit() {}Rabbit.prototype.jumps = true // Rabbit.prototype.constructor은 유지됨Rabbit.prototype = { jumps: true};ReferencesModern Javascript Tutorial" }, { "title": "modern js tutorial prototype inheritance", "url": "/posts/modern-js-tutorial-prototype-inheritance/", "categories": "JS", "tags": "javascript", "date": "2022-08-18 19:00:00 +0900", "snippet": "상속[[Prototype]]객체는 [[prototype]]라는 숨김 프로퍼티를 갖는데, null이거나 다른 객체에 대한 참조이다. 다른 객체를 참조하는 경우 참조 대상을 ‘프로토타입’이라 한다.프로토타입 상속: object에서 프로퍼티를 읽으려고 하는데 해당 프로퍼티가 없으면 자동으로 프로토타입에서 프로퍼티를 찾음.let animal = { eats: true};let rabbit = { jumps: true};rabbit.__proto__ = animal;rabbit.eats // true-&amp;gt; rabbit의 프로토타입은 animal이다. rabbit은 animal을 상속받는다.- __proto__는 [[Prototype]]의 getter이자 setter이다.- __proto__의 값은 객체나 null만 가능하다.- 객체엔 오직 하나의 [[Prototype]]만 있을 수 있다.let animal = { eats: true, walk() { }};let rabbit = { __proto__: animal};rabbit.walk = function() { alert(&quot;토끼가 깡충깡충 뜁니다.&quot;);};rabbit.walk(); // 실행시 프로토타입이 아닌 객체 rabbit에 직접 추가한 메서드가 실행됨this는 언제나 .앞에 있는 객체이다.let animal = { walk() { if (!this.isSleeping) { alert(`동물이 걸어갑니다.`); } }, sleep() { this.isSleeping = true; }};let rabbit = { name: &quot;하얀 토끼&quot;, __proto__: animal};// rabbit에 새로운 프로퍼티 isSleeping을 추가하고 그 값을 true로 변경합니다.rabbit.sleep();alert(rabbit.isSleeping); // truealert(animal.isSleeping); // undefined (프로토타입에는 isSleeping이라는 프로퍼티가 없습니다.)for…in은 상속 프로퍼티도 순회대상에 포함시킨다.let animal = { eats: true};let rabbit = { jumps: true, __proto__: animal};// Object.keys는 객체 자신의 키만 반환.alert(Object.keys(rabbit)); // jumps// for..in은 객체 자신의 키와 상속 프로퍼티의 키 모두를 순회.for(let prop in rabbit) alert(prop); // jumps, eats// hasOwnProperty 사용하여 자신의 키 or 상속을 구별할 수 있다.for(let prop in rabbit) { let isOwn = rabbit.hasOwnProperty(prop); if (isOwn) { alert(`객체 자신의 프로퍼티: ${prop}`); // 객체 자신의 프로퍼티: jumps } else { alert(`상속 프로퍼티: ${prop}`); // 상속 프로퍼티: eats }} rabbit은 animal을 상속animal은 Object.prototype을 상속(animal이 객체 리터럴 방식이기에)Object.prototype은 null을 상속프로토 체인의 프로퍼티를 공유하게 되는 경우let hamster = { stomach: [], eat(food) { this.stomach.push(food); }};let speedy = { __proto__: hamster, stomach: [] // 여기에 stomach가 없으면 speedy에는 stomach가 없기에 // hamster의 stomach를 공유하게 된다.};let lazy = { __proto__: hamster, stomach: []};// 햄스터 speedy가 음식을 먹습니다.speedy.eat(&quot;apple&quot;);alert( speedy.stomach ); // appleReferencesModern Javascript Tutorial" }, { "title": "modern js tutorial property getter setter", "url": "/posts/modern-js-tutorial-property-getter-setter/", "categories": "JS", "tags": "javascript", "date": "2022-08-17 19:00:00 +0900", "snippet": "property getter &amp;amp; setterlet user = { name: &quot;John&quot;, surname: &quot;Smith&quot;, get fullName() { return `${this.name} ${this.surname}`; }, set fullName(value) { // set의 인수는 하나 [this.name, this.surname] = value.split(&quot; &quot;); }};user.fullName //&#39;John Smith&#39;user.fullName = &#39;Milo Oh&#39;;user.fullName //&#39;Milo Oh&#39;;활용let user = { get name() { return this._name; }, set name(value) { if (value.length &amp;lt; 4) { alert(&quot;입력하신 값이 너무 짧습니다. 네 글자 이상으로 구성된 이름을 입력하세요.&quot;); return; } this._name = value; }};user.name = &quot;Pete&quot;;alert(user.name); // Peteuser의 이름은 name에 저장됨.** **““로 시작하는 프로퍼티는 객체 내부에서만 활용하고 외부에서는 건드리지 않는 것이 관습.function User(name, birthday) { this.name = name; this.birthday = birthday; // age는 현재 날짜와 생일을 기준으로 계산됩니다. Object.defineProperty(this, &quot;age&quot;, { get() { let todayYear = new Date().getFullYear(); return todayYear - this.birthday.getFullYear(); } });}let john = new User(&quot;John&quot;, new Date(1992, 6, 1));alert( john.birthday ); // birthday를 사용할 수 있습니다.alert( john.age ); // age 역시 사용할 수 있습니다.다음과 같이 설정하면 john.age = 3000 과 같이 임의적으로 설정이 불가능 하다.따라서 제약조건을 설정하거나 제한을 둘 때 사용가능.ReferencesModern Javascript Tutorial" }, { "title": "modern js tutorial bind", "url": "/posts/modern-js-tutorial-bind/", "categories": "JS", "tags": "javascript", "date": "2022-08-09 19:00:00 +0900", "snippet": "bindlet user = { firstName: &quot;John&quot;, sayHi() { alert(`Hello, ${this.firstName}!`); }};setTimeout(user.sayHi, 1000); // Hello, undefined!user.sayHi만 전달 되기 때문에 user의 firstName 읽지 못함.// setTimeout은 인수로 전달받은 함수 호출 할 때 this에 window를 할당함. // this.firstName = undefined래퍼 - 외부 렉시컬 환경에서 가져오기setTimeout(function() { user.sayHi(); // Hello, John!}, 1000);func.bind(context)는 특수객체를 반환하며, 이 객체를 호출하면 this가 context로 고정된 func가 반환됨.let user = { firstName: &quot;John&quot;};function func() { alert(this.firstName);}let funcUser = func.bind(user);funcUser(); // Johnlet user = { firstName: &quot;John&quot;, sayHi() { alert(`Hello, ${this.firstName}!`); }};let sayHi = user.sayHi.bind(user); // (*)// 이제 객체 없이도 객체 메서드를 호출할 수 있습니다.sayHi(); // Hello, John!setTimeout(sayHi, 1000); // Hello, John!부분 적용(2개의 인수 중 1개 고정)function mul(a, b) { return a * b;}let double = mul.bind(null, 2);alert( double(3) ); // = mul(2, 3) = 6alert( double(4) ); // = mul(2, 4) = 8alert( double(5) ); // = mul(2, 5) = 10화살표 함수 화살표 함수는 어떤 것도 바인딩시키지 않음. this가 없음. 화살표 함수에서 this 사용시 외부 렉시컬 환경에서 찾는다.ReferencesModern Javascript Tutorial" }, { "title": "modern js tutorial call and apply", "url": "/posts/modern-js-tutorial-call-and-apply/", "categories": "JS", "tags": "javascript", "date": "2022-08-08 19:00:00 +0900", "snippet": "func.callfunc.call(context, arg1, arg2, …)func(1, 2, 3);func.call(obj, 1, 2, 3);동일하지만, func.call 에서는 this가 obj로 고정됨.1.function sayHi() { alert(this.name);}let user = { name: &quot;John&quot; };let admin = { name: &quot;Admin&quot; };sayHi.call( user ); // this = JohnsayHi.call( admin ); // this = Admin2.function say(phrase) { alert(this.name + &#39;: &#39; + phrase);}let user = { name: &quot;John&quot; };say.call( user, &quot;Hello&quot; ); // John: Hellofunc.applyfunc.apply(context, args)call은 복수 인수를 따로따로 받음. apply는 인수를 유사 배열 객체로 받음.func.call(context, ...args); // 전개 문법을 사용해 인수가 담긴 배열을 전달하는 것과func.apply(context, args); // call을 사용하는 것은 동일합니다.ReferencesModern Javascript Tutorial" }, { "title": "modern js tutorial scheduling call", "url": "/posts/modern-js-tutorial-scheduling-call/", "categories": "JS", "tags": "javascript", "date": "2022-07-29 23:45:00 +0900", "snippet": "setTimeout일정 시간이 지난 후에 함수를 실행하는 방법사용법function sayHi(who, phrase) { alert( who + &#39; 님, &#39; + phrase );}setTimeout(sayHi, 1000, &quot;홍길동&quot;, &quot;안녕하세요.&quot;); // 홍길동 님, 안녕하세요.// 잘못된 코드 - 함수에 ()를 붙이면 return값이 들어온다.setTimeout(sayHi(), 1000);스케줄링 취소let timerId = setTimeout(...);clearTimeout(timerId);중첩(setInterval보다 좀 더 유연하게 사용 가능)let timerId = setTimeout(function tick() { alert(&#39;째깍&#39;); timerId = setTimeout(tick, 2000); // (*)}, 2000);setInterval일정 시간 간격을 두고 함수를 실행하는 방법// 2초 간격으로 메시지를 보여줌let timerId = setInterval(() =&amp;gt; alert(&#39;째깍&#39;), 2000);// 5초 후에 정지setTimeout(() =&amp;gt; { clearInterval(timerId); alert(&#39;정지&#39;); }, 5000);setInterval 사용시 함수 실행 소모 시간도 지연 간격에 포함되기 때문에 실제 설정한 시간보다 짧아짐중첩 setTimeout 사용시 설정한 지연 시간이 보장된다.ReferencesModern Javascript Tutorial" }, { "title": "modern js tutorial closure", "url": "/posts/modern-js-tutorial-closure/", "categories": "JS", "tags": "javascript", "date": "2022-07-26 23:45:00 +0900", "snippet": "Lexical Environment변수 환경 레코드(Environment Record): 모든 지역 변수를 프로퍼티로 저장하고 있는 객체. this값과 같은 기타 정보 포함. 외부 렉시컬(Outer Lexical Environment): 외부 코드와 연관됨.‘변수’는 환경 레코드의 프로퍼티.함수 선언문함수 선언문으로 선언한 함수는 바로 초기화 된다.내부와 외부 Lexical Environmentlet phrase = &#39;Hello&#39;;function say(name){ alert( `${phrase}, ${name});}say(&quot;John&quot;); 함수 호출 중 내부 렉시컬 환경과 외부 렉시컬 환경을 갖게 됨. 내부 렉시컬 환경 : name(John) 외부 렉시컬 환경 = 전역 렉시컬 환경 : phrase, say**코드에서 변수에 접근할 때, 먼저 내부 렉시컬 환경 검색. ****내부에 원하는 변수가 없으면 내부 렉시컬 환경이 참조하는 외부 렉시컬 환경으로 확장 ****이 과정은 검색 범위가 전역 렉시컬 환경으로 확장될 때까지 반복 **함수를 반환하는 함수function makeCounter(){ let count = 0; return function(){ return count++; }}let counter = makeCounter(); makeCounter()를 호출할 때마다 새로운 렉시컬 환경 객체가 만들어지고, 여기에 makeCounter를 실행하는데 필요한 변수들이 저장된다. 모든 함수는 함수가 생성된 곳의 렉시컬 환경을 기억한다.([[Environment]]라 불리는 숨김 프로퍼티) 따라서 counter.[[Environment]]에는 {count:0}이 있는 렉시컬 환경에 대한 참조 저장 count++가 실행되면서 count 값이 증가하는데, 변숫값 갱신은 변수가 저장된 렉시컬 환경에서 이뤄짐.가비지 컬렉션함수 호출이 끝나면 함수에 대응하는 렉시컬 환경이 메모리에서 제거됨.(객체는 도달 가능한 상태일 때만 메모리에 유지)호출이 끝난 후에도 여전히 도달 가능한 중첩 함수가 있을 수 있고, [[Environment]]에 외부 함수 렉시컬 환경에 대한 정보가 저장됨function f() { let value = 123; return function() { alert(value); }}let g = f(); // g가 살아있는 동안엔 연관 렉시컬 환경도 메모리에 살아있습니다.g = null; // 도달할 수 없는 상태가 되었으므로 메모리에서 삭제됩니다.하지만 실제로는 자바스크립트 엔진이 이를 지속해서 최적화 작업 진행. 외부 변수가 사용되지 않는다고 판단하면 이를 메모리에서 제거.(V8에서 제거된 변수는 사용할 수 없음)let value = &quot;이름이 같은 다른 변수&quot;;function f() { let value = &quot;가장 가까운 변수&quot;; function g() { debugger; // 콘솔에 alert(value);를 입력하면 &#39;이름이 같은 다른 변수&#39;가 출력됩니다. } return g;}let g = f();g();예시function makeCounter() { let count = 0; return function() { return count++; };}let counter = makeCounter();let counter2 = makeCounter();alert( counter() ); // 0alert( counter() ); // 1alert( counter2() ); // ?alert( counter2() ); // ? 두 함수는 독립적인 렉시컬 환경을 갖게되므로 각 함수는 자신만의 count를 갖게 됨.ReferencesModern Javascript Tutorial" }, { "title": "modern js tutorial spread", "url": "/posts/modern-js-tutorial-spread/", "categories": "JS", "tags": "javascript", "date": "2022-07-23 23:30:00 +0900", "snippet": "…function sumAll(...args) { // args는 배열의 이름입니다. let sum = 0; for (let arg of args) sum += arg; return sum;}alert( sumAll(1) ); // 1alert( sumAll(1, 2) ); // 3alert( sumAll(1, 2, 3) ); // 6변수가 여러개 일 때, 나머지 매개변수는 항상 마지막에 있어야 한다.argumentsarguments는 유사배열객체이면서 이터러블 객체. 하지만 배열은 아니기에 배열 메서드 사용 불가.화살표 함수에서는 arguments 객체 지원 불가function showName() { alert( arguments.length ); alert( arguments[0] ); alert( arguments[1] ); // arguments는 이터러블 객체이기 때문에 // for(let arg of arguments) alert(arg); 를 사용해 인수를 펼칠 수 있습니다.}// 2, Bora, Lee가 출력됨showName(&quot;Bora&quot;, &quot;Lee&quot;);// 1, Bora, undefined가 출력됨(두 번째 인수는 없음)showName(&quot;Bora&quot;);spread배열 및 이터러블 객체라면 스프레드 문법 사용 가능let arr = [3, 5, 1];alert( Math.max(arr) ); // NaN // 숫자 목록을 인수로 받는다.alert( Math.max(...arr) ); // 5let arr = [3, 5, 1];let arr2 = [8, 9, 15];let merged = [0, ...arr, 2, ...arr2]; // 병합let str = &quot;Hello&quot;; // 문자열alert( [...str] ); // H,e,l,l,oalert( Array.from(str) ); // H,e,l,l,o Array.from - 유사배열객체, 이터러블 객체 둘 다 사용 가능spread - 이터러블 객체에만 사용 가능copylet arr = [1, 2, 3];let arrCopy = [...arr];alert(JSON.stringify(arr) === JSON.stringify(arrCopy)); // truealert(arr === arrCopy); // falselet obj = { a: 1, b: 2, c: 3 };let objCopy = { ...obj };alert(JSON.stringify(obj) === JSON.stringify(objCopy)); // truealert(obj === objCopy); // falseReferencesModern Javascript Tutorial" }, { "title": "typescript generic", "url": "/posts/typescript-generic/", "categories": "TS", "tags": "typescript", "date": "2022-07-18 23:20:00 +0900", "snippet": "Genericbasicfunction merge(objA: object, objB: object) { return Object.assign(objA, objB);}const mergedObj = merge({ name: &quot;Milo&quot; }, { sex: &quot;M&quot; });mergedObj.name // Error!// typescript는 두 object를 결합하여 return 한다는 것만 알고 있지,// return된 값 안에 어떤 속성이 있는지 알 수 없다.function merge&amp;lt;T, U&amp;gt;(objA: T, objB: U) { // generic을 지정해준다 return Object.assign(objA, objB);}const mergedObj = merge({ name: &quot;Milo&quot; }, { sex: &quot;M&quot; });mergedObj.name; // OKmergedObj.sex; // OK// 제약조건 추가(두 인자 모두 객체여야 한다)function merge&amp;lt;T extends object, U extends object&amp;gt;(objA: T, objB: U) { return Object.assign(objA, objB);}keyoffunction extractAndConvert&amp;lt;T extends object, U extends keyof T&amp;gt;( obj: T, key: U) { return &#39;Value: &#39; + obj[key];}extractAndConvert({ name: &#39;Max&#39; }, &#39;name&#39;);// keyof를 통하여 두번째 인자가 첫번째 객체의 키에 존재 하는지 검사classesclass DataStorage&amp;lt;T extends string | number | boolean&amp;gt; { // 원시타입으로 제약 private data: T[] = []; addItem(item: T) { this.data.push(item); } removeItem(item: T) { if (this.data.indexOf(item) === -1) { return; } this.data.splice(this.data.indexOf(item), 1); // -1 } getItems() { return [...this.data]; }}const textStorage = new DataStorage&amp;lt;string&amp;gt;(); // generic settingtextStorage.addItem(&#39;Max&#39;);textStorage.addItem(&#39;Manu&#39;);textStorage.removeItem(&#39;Max&#39;);console.log(textStorage.getItems());Partialinterface CourseGoal { title: string; description: string; completeUntil: Date;}function createCourseGoal(title: string, description: string, date: Date): CourseGoal { let courseGoal: Partial&amp;lt;CourseGoal&amp;gt; = {}; // CourseGoal interface가 모두 optional이 됨 courseGoal.title = title; courseGoal.description = description; courseGoal.completeUntil = date; return courseGoal as CourseGoal;}Referenceshttps://www.typescriptlang.org/docs/handbook/tsconfig-json.htmlhttps://www.udemy.com/course/best-typescript-21/" }, { "title": "typescript decorator", "url": "/posts/typescript-decorator/", "categories": "TS", "tags": "typescript", "date": "2022-07-18 16:20:00 +0900", "snippet": "settingtsconfig.json{ &quot;compilerOptions&quot;: { ... &quot;experimentalDecorators&quot;: true }}basicfunction Logger(constructor: Function) { console.log(&#39;Logging...&#39;); console.log(constructor);}@Loggerclass Person { name = &#39;Max&#39;; constructor() { console.log(&#39;Creating person object...&#39;); }}const pers = new Person();console.log(pers);-----Log-----Logging...app.ts:3 class Person { constructor() { this.name = &#39;Max&#39;; console.log(&#39;Creating person object...&#39;); }}app.ts:11 Creating person object...app.ts:17 Person {name: &#39;Max&#39;}-----decorator factoryfunction Logger(logString: string) { return function (constructor: Function) { console.log(logString); console.log(constructor); };}@Logger(&quot;LOGGING - PERSON&quot;)class Person { name = &quot;Max&quot;; constructor() { console.log(&quot;Creating person object...&quot;); }}useful decorator// 전달받은 &#39;app&#39; element에 name 삽입하는 예제function WithTemplate(template: string, hookId: string) { return function (constructor: any) { const hookEl = document.getElementById(hookId); const p = new constructor(); if (hookEl) { hookEl.innerHTML = template; hookEl.querySelector(&quot;h1&quot;)!.textContent = p.name; } };}@WithTemplate(&quot;&amp;lt;h1&amp;gt;My Person Object&amp;lt;/h1&amp;gt;&quot;, &quot;app&quot;)class Person { name = &quot;Max&quot;; constructor() { console.log(&quot;Creating person object...&quot;); }}Referenceshttps://www.typescriptlang.org/docs/handbook/tsconfig-json.htmlhttps://www.udemy.com/course/best-typescript-21/" }, { "title": "typescript advanced type", "url": "/posts/typescript-advanced-type/", "categories": "TS", "tags": "typescript", "date": "2022-07-17 23:35:00 +0900", "snippet": "advanced typeintersection typetype Admin = { name: string; privileges: string[];};type Employee = { name: string; startDate: Date;};// interface ElevatedEmployee extends Employee, Admin {}type ElevatedEmployee = Admin &amp;amp; Employee;const e1: ElevatedEmployee = { name: &#39;Max&#39;, privileges: [&#39;create-server&#39;], startDate: new Date()};type guard특정 속성이나 메소드를 사용하기 전에 존재하는지 확인하거나 타입이 일치하는지 확인작업 typeof (타입확인) 속성 in 객체 instanceof (interface가 아닌 type일 때)type Combinable = string | number;type Numeric = number | boolean;type Universal = Combinable &amp;amp; Numeric;function add(a: Combinable, b: Combinable) { if (typeof a === &#39;string&#39; || typeof b === &#39;string&#39;) { return a.toString() + b.toString(); } return a + b;}type UnknownEmployee = Employee | Admin;function printEmployeeInformation(emp: UnknownEmployee) { console.log(&#39;Name: &#39; + emp.name); if (&#39;privileges&#39; in emp) { console.log(&#39;Privileges: &#39; + emp.privileges); } if (&#39;startDate&#39; in emp) { console.log(&#39;Start Date: &#39; + emp.startDate); }}class Car { drive() { console.log(&#39;Driving...&#39;); }}class Truck { drive() { console.log(&#39;Driving a truck...&#39;); } loadCargo(amount: number) { console.log(&#39;Loading cargo ...&#39; + amount); }}type Vehicle = Car | Truck;const v1 = new Car();const v2 = new Truck();function useVehicle(vehicle: Vehicle) { vehicle.drive(); if (vehicle instanceof Truck) { vehicle.loadCargo(1000); }}discriminated unioninterface Bird { type: &#39;bird&#39;; flyingSpeed: number;}interface Horse { type: &#39;horse&#39;; runningSpeed: number;}type Animal = Bird | Horse;function moveAnimal(animal: Animal) { let speed; switch (animal.type) { case &#39;bird&#39;: speed = animal.flyingSpeed; break; case &#39;horse&#39;: speed = animal.runningSpeed; } console.log(&#39;Moving at speed: &#39; + speed);}type casting1. &amp;lt;&amp;gt; + ! 를 통한 castingconst userInputElement = &amp;lt;HTMLInputElement&amp;gt;document.getElementById(&#39;user-input&#39;)!;2. as + ! 를 통한 castingconst userInputElement = document.getElementById(&#39;user-input&#39;)! as HTMLInputElement;3. as + ifconst userInputElement = document.getElementById(&#39;user-input&#39;);// !이 없으면 HTMLElement | null 이므로 if를 사용하여 null이 아닐 때 실행if (userInputElement) { (userInputElement as HTMLInputElement).value = &#39;Hi there!&#39;;}index propertiesinterface ErrorContainer { [prop: string]: string; // 정확한 속성 이름, 개수 모를 때. 속성, 속성값 string로 설정,}Referenceshttps://www.typescriptlang.org/docs/handbook/tsconfig-json.htmlhttps://www.udemy.com/course/best-typescript-21/" }, { "title": "typescript class and interface", "url": "/posts/typescript-class-and-interface/", "categories": "TS", "tags": "typescript", "date": "2022-07-16 00:20:00 +0900", "snippet": "Classclass and thisclass Department { name: string; constructor(n: string) { this.name = n; } describe(this: Department) { console.log(&#39;Department: &#39; + this.name); }}const accounting = new Department(&#39;Accounting&#39;);accounting.describe();private and publicclass Department { public name: string; private employees: string[] = []; // private 설정으로 외부의 직접적인 접근 forbid constructor(n: string) { this.name = n; } describe(this: Department) { console.log(&#39;Department: &#39; + this.name); } addEmployee(employee: string) { // private 인자는 내부 메소드로 접근 // validation etc this.employees.push(employee); } printEmployeeInformation() { console.log(this.employees.length); console.log(this.employees); }}const accounting = new Department(&#39;Accounting&#39;);accounting.addEmployee(&#39;Max&#39;);accounting.addEmployee(&#39;Manu&#39;);shorter initclass Department { // private id: string; // private name: string; private employees: string[] = []; // 바로 명시하여 this 통하여 주입할 필요 x constructor(private id: string, public name: string) { // this.id = id; // this.name = n; } describe(this: Department) { console.log(`Department (${this.id}): ${this.name}`); } addEmployee(employee: string) { // validation etc this.employees.push(employee); } printEmployeeInformation() { console.log(this.employees.length); console.log(this.employees); }}Inheritanceclass Department { // private readonly id: string; // private name: string; private employees: string[] = []; constructor(private readonly id: string, public name: string) { // this.id = id; // this.name = n; } describe(this: Department) { console.log(`Department (${this.id}): ${this.name}`); } addEmployee(employee: string) { // validation etc // this.id = &#39;d2&#39;; this.employees.push(employee); } printEmployeeInformation() { console.log(this.employees.length); console.log(this.employees); }}class ITDepartment extends Department { admins: string[]; constructor(id: string, admins: string[]) { // extends시 super호출 필요 super(id, &#39;IT&#39;); this.admins = admins; }}class AccountingDepartment extends Department { constructor(id: string, private reports: string[]) { super(id, &#39;Accounting&#39;); } addReport(text: string) { this.reports.push(text); } printReports() { console.log(this.reports); }}const it = new ITDepartment(&#39;d1&#39;, [&#39;Max&#39;]);it.addEmployee(&#39;Max&#39;);it.addEmployee(&#39;Manu&#39;);getters and settersclass AccountingDepartment extends Department { private lastReport: string; //private 지정하여 외부에서 접근 forbid get mostRecentReport() { // getter 설정 if (this.lastReport) { return this.lastReport; } throw new Error(&#39;No report found.&#39;); } set mostRecentReport(value: string) { // setter 설정 if (!value) { throw new Error(&#39;Please pass in a valid value!&#39;); } this.addReport(value); } constructor(id: string, private reports: string[]) { super(id, &#39;Accounting&#39;); this.lastReport = reports[0]; } addEmployee(name: string) { if (name === &#39;Max&#39;) { return; } this.employees.push(name); } addReport(text: string) { this.reports.push(text); this.lastReport = text; } printReports() { console.log(this.reports); }}Abstractabstract class Department { static fiscalYear = 2020; protected employees: string[] = []; constructor(protected readonly id: string, public name: string) { } static createEmployee(name: string) { return { name: name }; } abstract describe(this: Department): void; // 추상클래스 선언 addEmployee(employee: string) { // validation etc // this.id = &#39;d2&#39;; this.employees.push(employee); } printEmployeeInformation() { console.log(this.employees.length); console.log(this.employees); }}class ITDepartment extends Department { admins: string[]; constructor(id: string, admins: string[]) { super(id, &#39;IT&#39;); this.admins = admins; } describe() { // 추상클래스 구현 (미구현시 error) console.log(&#39;IT Department - ID: &#39; + this.id); }}class AccountingDepartment extends Department { private lastReport: string; get mostRecentReport() { if (this.lastReport) { return this.lastReport; } throw new Error(&#39;No report found.&#39;); } set mostRecentReport(value: string) { if (!value) { throw new Error(&#39;Please pass in a valid value!&#39;); } this.addReport(value); } constructor(id: string, private reports: string[]) { super(id, &#39;Accounting&#39;); this.lastReport = reports[0]; } describe() { // 추상클래스 구현 (미구현시 error) console.log(&#39;Accounting Department - ID: &#39; + this.id); } addEmployee(name: string) { if (name === &#39;Max&#39;) { return; } this.employees.push(name); } addReport(text: string) { this.reports.push(text); this.lastReport = text; } printReports() { console.log(this.reports); }}Singletoneclass AccountingDepartment extends Department { private lastReport: string; private static instance: AccountingDepartment; ... static getInstance() { if (AccountingDepartment.instance) { // Instance 생성됐으면 바로 리턴 return this.instance; } this.instance = new AccountingDepartment(&#39;d2&#39;, []); // 없으면 새로 생성 return this.instance; }}Interfacebasicinterface Person { //interface 선언 name: string; age: number; greet(phrase: string): void;}let user1: Person;user1 = { //interface 구현 name: &#39;Max&#39;, age: 30, greet(phrase: string) { console.log(phrase + &#39; &#39; + this.name); }};user1.greet(&#39;Hi there - I am&#39;);Implementinginterface Greetable { name: string; greet(phrase: string): void;}class Person implements Greetable { name: string; age = 30; // Implement하면 interface에 없는 요소도 추가가능 constructor(n: string) { this.name = n; } greet(phrase: string) { console.log(phrase + &#39; &#39; + this.name); }}Referenceshttps://www.typescriptlang.org/docs/handbook/tsconfig-json.htmlhttps://www.udemy.com/course/best-typescript-21/" }, { "title": "typescript compile", "url": "/posts/typescript-compile/", "categories": "TS", "tags": "typescript", "date": "2022-07-14 14:30:00 +0900", "snippet": "Typescript compile기본(1 file)$tsc app.ts자동 컴파일(1 file)$tsc app.ts --watch다수 파일 (전체 프로젝트)$tsc --init // 프로젝트 초기에 한번만 실행$tsc // 전체 컴파일$tsc --watch // 전체 컴파일 자동특정 파일들만 컴파일tsconfig.json{ &quot;compilerOptions&quot;: { ... }, &quot;include&quot;: [&quot;app.ts&quot;, &quot;basic.ts&quot;]}tsconfig.json target: 변환하고자 하는 js version lib: 사용할 라이브러리 es6 default(주석처리시): dom, es6, dom.iterable, scripthost sourceMap: 브라우저 Sources에서 ts 파일 확인 가능(디버깅 용이) outDir: 컴파일된 js파일 저장 위치 rootDir: 컴파일 시작 위치(default: 가장 상위 디렉토리)Referenceshttps://www.typescriptlang.org/docs/handbook/tsconfig-json.html https://www.udemy.com/course/best-typescript-21/" }, { "title": "modern js tutorial iterable", "url": "/posts/modern-js-tutorial-iterable/", "categories": "JS", "tags": "javascript", "date": "2022-07-12 00:30:00 +0900", "snippet": "자료구조iterable 객체배열 및 문자열 같이 반복 할 수 있는 객체.Symbol.iterator for..of가 시작되자마자 for..of는 Symbol.iterator를 호출한다. Symbol.iterator은 iterator를 반환한다. 이후 for..of는 반환된 객체만을 대상으로 동작한다. for..of 다음 값이 필요하면 iterator의 next() 메서드를 호출한다. next()의 반환 값은 {done: Boolean, value: any} 형태.let range = { from: 1, to: 5, [Symbol.iterator]() { this.current = this.from; return this; }, next() { if (this.current &amp;lt;= this.to) { return { done: false, value: this.current++ }; } else { return { done: true }; } }};for (let num of range) { alert(num); // 1, then 2, 3, 4, 5}이터러블과 유사배열 이터러블(iterable): Symbol.iterator가 구현된 객체 유사배열(array-like): 인덱스와 length 프로퍼티가 있어서 배열처럼 보이는 객체let arrayLike = { // 인덱스와 length프로퍼티가 있음 =&amp;gt; 유사 배열 0: &quot;Hello&quot;, 1: &quot;World&quot;, length: 2};// Symbol.iterator가 없으므로 에러 발생for (let item of arrayLike) {}Array.from이터러블이나 유사배열을 받아 Array로 만들어줌.let arrayLike = { 0: &quot;Hello&quot;, 1: &quot;World&quot;, length: 2};let arr = Array.from(arrayLike); // 이터러블 or 유사배열 조사후 새로운 배열 생성 및 복사alert(arr.pop()); // World (메서드가 제대로 동작합니다.)mapping 함수 적용 : 배열에 요소를 추가하기 전에 mapFn 적용 가능Array.from(obj[, mapFn, thisArg])// 각 숫자를 제곱let arr = Array.from(range, num =&amp;gt; num * num);alert(arr); // 1,4,9,16,25ReferencesModern Javascript Tutorial" }, { "title": "modern js tutorial data structure", "url": "/posts/modern-js-tutorial-data-structure/", "categories": "JS", "tags": "javascript", "date": "2022-07-11 15:30:00 +0900", "snippet": "자료구조원시값의 메서드JS에서 원시값을 마치 객체처럼 다룰 수 있으며 메서드를 호출할 수 있다.원시값(primitive) 문자(string), 숫자(number), bigint, 불린(boolean), 심볼(symbol), null, undefined객체(object) 프로퍼티에 다양한 종류의 값을 저장할 수 있다.원시 래퍼 객체(object wrapper) 원시값은 원시값 그대로 남겨둬 단일 값 형태를 유지한다. 문자열, 숫자, 불린, 심볼의 메서드와 프로퍼티에 접근할 수 있도록 언어 차원에서 허용한다. 이를 가능하게 하기 위해, 원시값이 메서드나 프로퍼티에 접근하려 하면 추가 기능을 제공해주는 특수한 객체, “원시 래퍼 객체(object wrapper)”를 만들어 준다. 이 객체는 곧 삭제된다. String, Number, Boolean, Symbollet str = &quot;Hello&quot;;alert( str.toUpperCase() ); // HELLO toUpperCase에 접근하는 순간 특별한 객체가 만들어짐. 메서드가 실행되고 새로운 문자열이 반환됨. 특별한 객체는 파괴되고, 원시값 str만 남음.숫자형다수의 0을 입력하기 0의 개수를 ‘e’ 뒤에 추가한다. 123e6은 0이 6개인 숫자, 123000000을 나타냄. ‘e’ 다음에 음수가 오면 음수의 절댓값 만큼 10을 거듭제곱한 숫자로 주어진 숫자를 나눈다. 123e-6은 0.000123Number Parse (parseInt, parseFloat)불가능할 때까지 문자열에서 숫자를 읽는다. 읽는 도중 오류가 발생하면 이미 수집된 숫자를 반환. **읽을 수 있는 숫자가 없으면 NaN **alert( parseInt(&#39;100px&#39;) ); // 100alert( parseFloat(&#39;12.5em&#39;) ); // 12.5alert( parseInt(&#39;12.3&#39;) ); // 12, 정수 부분만 반환됩니다.alert( parseFloat(&#39;12.3.4&#39;) ); // 12.3, 두 번째 점에서 숫자 읽기를 멈춥니다.배열배열 shift 메서드 호출시 수행되는 작업 인덱스 0인 요소를 제거. 모든 요소를 왼쪽으로 이동. length 프로퍼티 값 갱신.따라서 shift, unshift는 push, pop에 비해 속도가 느리다배열에는 되도록이면 for..in을 쓰지말자. for..in은 모든 프로퍼티를 대상으로 순회한다. 키가 숫자가 아닌 프로퍼티도 순회 대상. 예를들어 유사배열의 경우 불필요한 프로퍼티로 인해 문제가 발생할 소지가 높다. for..in은 객체와 함께 사용할 때 최적화 되어 있다.배열 ‘length’ 프로퍼티는 배열 내 요소 개수가 아닌 가장 큰 인덱스+1 이다.배열의 toString배열엔 toString 메서드가 구현되어있다.let arr = [1, 2, 3];alert( arr ); // 1,2,3alert( String(arr) === &#39;1,2,3&#39; ); // true배열 여부 확인 Array.isArrayalert(Array.isArray({})); // falsealert(Array.isArray([])); // trueReferencesModern Javascript Tutorial" }, { "title": "modern js tutorial obj", "url": "/posts/modern-js-tutorial-core/", "categories": "JS", "tags": "javascript", "date": "2022-07-07 21:30:00 +0900", "snippet": "객체computed property객체 프로퍼티 키가 대괄호로 둘러싸여 있는 경우let fruit = prompt(&quot;어떤 과일을 구매하시겠습니까?&quot;, &quot;apple&quot;);let bag = { [fruit]: 5, // 변수 fruit에서 프로퍼티 이름을 동적으로 받아 옵니다.};alert( bag.apple ); // fruit에 &quot;apple&quot;이 할당되었다면, 5가 출력됩니다.let fruit = &#39;apple&#39;;let bag = { [fruit + &#39;Computers&#39;]: 5 // bag.appleComputers = 5};‘in’연산자로 객체 프로퍼티 존재 확인let user = { name: &quot;John&quot;, age: 30 };alert( &quot;age&quot; in user ); // user.age가 존재하므로 true가 출력됩니다.alert( &quot;blabla&quot; in user ); // user.blabla는 존재하지 않기 때문에 false가 출력됩니다.객체의 복사for문 복사let user = { name: &quot;John&quot;, age: 30};let clone = {}; // 새로운 빈 객체// 빈 객체에 user 프로퍼티 전부를 복사해 넣습니다.for (let key in user) { clone[key] = user[key];}// 이제 clone은 완전히 독립적인 복제본이 되었습니다.clone.name = &quot;Pete&quot;; // clone의 데이터를 변경합니다.alert( user.name ); // 기존 객체에는 여전히 John이 있습니다.Object.assign 복사let user = { name: &quot;John&quot; };let permissions1 = { canView: true };let permissions2 = { canEdit: true };// permissions1과 permissions2의 프로퍼티를 user로 복사합니다.Object.assign(user, permissions1, permissions2);// now user = { name: &quot;John&quot;, canView: true, canEdit: true }위 두 방법 모두 객체의 모든 프로퍼티가 원시값일 경우만 가능하다. 객체 안에 또 다른 객체 형태가 존재한다면 깊은복사 알고리즘 구현 or lodash의 _.cloneDeep(obj)이용가비지 컬렉션garbage collector은 끊임없이 동작하며 모든 객체를 모니터링하고, 도달할 수 없는 객체는 삭제한다.mark-and-sweep 가비지 컬렉터는 루트 정보를 수집하고 이를 mark 한다. 루트가 참조하고 있는 모든 객체를 방문하고 이것들을 mark 한다. mark된 모든 객체에 방문하고 그 객체들이 참조하는 객체도 mark 한다. 한번 방문한 객체는 전부 mark하기에 같은 객체를 다시 방문하는 일은 없다. 루트에서 도달 가능한 모든 객체를 방문할 때까지 위 과정을 반복한다. mark 되지 않은 모든 객체를 메모리에서 삭제한다.this this 값은 런타임에 결정됨. object.method() 같이 메서드 형태로 호출시 this는 object를 참조함. 화살표 함수 안에서 this 사용시 외부에서 this 값을 가져옴.let user = { firstName: &quot;보라&quot;, sayHi() { let arrow = () =&amp;gt; alert(this.firstName); arrow(); }};user.sayHi(); // 보라생성자 함수생성자 함수는 아래 두 관례를 따른다. 함수 이름의 첫 글자는 대문자로 시작. 반드시 ‘new’ 연산자를 붙여 실행.function User(name) { this.name = name; this.isAdmin = false;}let user = new User(&quot;보라&quot;);alert(user.name); // 보라alert(user.isAdmin); // falseReferencesModern Javascript Tutorial" }, { "title": "modern js tutorial basic", "url": "/posts/modern-js-tutorial-basic/", "categories": "JS", "tags": "javascript", "date": "2022-07-05 14:30:00 +0900", "snippet": "Javascript정의 ‘웹페이지에 생동감을 불어넣기 위해’ 만들어진 프로그래밍 언어. 브라우저 및 서버에서 실행 가능. 브라우저 엔진 V8 - Chrome, Opera SpiderMonkey - Firefox ChakgraCore - Microsoft Edge SquirrelFish - Safari 엔진 동작 방식 엔진이 스크립트를 읽는다(파싱) 기계어로 전환(컴파일) 기계어로 전환된 코드를 실행JS의 강점 HTML/CSS와 완전 통합 가능 간단한 일은 간단하게 처리 가능 모든 주요 브라우저에서 지원, 기본 언어로 사용JS 기본 자료형 숫자형 - 정수, 부동 소주점 숫다 등 bigint - 길이 제약 없는 정수 문자형 - 문자열 boolean - true or false null undefined - 할당되지 않은 값 객체형 - 복잡한 데이터 구조 표현 심볼형 - 객체의 고유 식별자를 만들 때 사용‘&amp;amp;&amp;amp;’ and ‘||’&amp;amp;&amp;amp; 는 첫 번째 falsy 값을 찾는다.&amp;amp;&amp;amp; 는 모든 피연산자가 true로 평가되는 경우 =&amp;gt; 마지막 피연상자가 반환된다.|| 는 첫 번째 truthy 값을 찾고 boolean이 아닌 해당 피연산자의 **변환 전** 원래 값 반환한다.|| 는 truthy 값이 없을 경우 마지막 피연산자를 반환한다.nullish 병합 연산자 ‘??’x = (a !== null &amp;amp;&amp;amp; a !== undefined) ? a: b;’??’와 ‘||’의 차이let height = 0;alert(height || 100); // 100alert(height ?? 100); // 0** 안정성 관련 이슈 때문에 ??는 &amp;amp;&amp;amp;나 ||와 함께 사용하지 못합니다.(괄호 사용 필요)**함수 함수는 이름에 언급된 동작 하나만 담당해야 한다. 함수 네이밍 ex) “get…”, “calc…”, “create…”, “check…” 깔끔한 코드를 위해 지역 변수와 매개변수 활용변수명명규칙 숫자와 문자 사용하되 첫 글자는 숫자가 될 수 없음. 특수기호는 $와 _만 사용가능 자료형을 바꿔가며 값 할당 가능바벨바벨은 transpiler로, 모던 자바스크립트 코드를 구 표준을 준수하는 코드로 바꿔준다.ReferencesModern Javascript Tutorial" }, { "title": "react scroll throttle and debounce", "url": "/posts/react-scroll-throttle-debounce/", "categories": "REACT", "tags": "react", "date": "2022-06-30 21:30:00 +0900", "snippet": "Throttle &amp;amp; Debounce 사용이유Scroll, Submit 등의 이벤트가 과도하게 동작하거나 중복처리 됨을 방지하기 위해서 사용. 예를들어 here 에서 확인해보면 이벤트 발생 횟수를 비교해 볼 수 있다. 밑의 React 코드도 마찬가지이다.정의 Throttle : 마지막 함수가 호출된 후 일정 시간이 지나기 전에 다시 호출되지 않도록 하는 것 ex) Scroll event Infinite scrolling throttled Debounce : 연이어 호출되는 함수들 중 마지막 함수(또는 제일 처음)만 호출하도록 하는 것 ex) Search시 입력을 멈췄을 때 only works once! 사용아래 React 코드와 같이 직접 구현해도 되지만 lodash, underscore의 _.throttle or _.debounce도 많이 이용하는 것으로 보인다.const handleScroll = (e) =&amp;gt; { console.log(window.scrollY);};//normaluseEffect(() =&amp;gt; { window.addEventListener(&quot;scroll&quot;, handleScroll); return () =&amp;gt; { window.removeEventListener(&quot;scroll&quot;, handleScroll); };}, []);// debounceuseEffect(() =&amp;gt; { var timer; window.addEventListener(&quot;scroll&quot;, () =&amp;gt; { if (timer) { clearTimeout(timer); } timer = setTimeout(() =&amp;gt; { timer = null; handleScroll(); }, 200); }); return () =&amp;gt; { window.removeEventListener(&quot;scroll&quot;, handleScroll); };}, []);// throttleuseEffect(() =&amp;gt; { var timer; window.addEventListener(&quot;scroll&quot;, () =&amp;gt; { if (!timer) { timer = setTimeout(() =&amp;gt; { timer = null; handleScroll(); }, 200); } }); return () =&amp;gt; { window.removeEventListener(&quot;scroll&quot;, handleScroll); };});Referenceshttps://codepen.io/dcorb/pen/eJLMxa https://codepen.io/chriscoyier/pen/vOZNQV https://www.zerocho.com/category/JavaScript/post/59a8e9cb15ac0000182794fa" }, { "title": "react url changed, not refresh", "url": "/posts/react-same-url-refresh/", "categories": "REACT, Error", "tags": "react", "date": "2022-06-25 23:30:00 +0900", "snippet": "react router에서 url 변경시 새로고침이 안되는 경우가 있다.현상 /product/1 =&amp;gt; /product/2 url은 변경되지만 렌더링은 일어나지 않음으로 화면은 변경되지 않는다.해결법 위와 같은 같은 url 끼리의 이동이라면 useParams를 이용하여 변경되었는지 확인한 후 데이터를 재 fetch 해오면 된다.useParams in React-Router-Dom v6" }, { "title": "react custom hook", "url": "/posts/react-custom-hook/", "categories": "REACT", "tags": "react", "date": "2022-06-22 23:30:00 +0900", "snippet": "Custom hook반복되는 로직의 재사용Rule custom hook은 use로 시작한다. 최상위(at the Top Level)에서만 Hook을 호출해야 한다. 반복문, 조건문 or 중첩된 함수 내에서 Hook호출 X 오직 React함수 내에서 Hook을 호출해야 한다. 일반 Javascript 함수에서 호출 X React custom hook vs Javascript Util function 차이점useState, useEffect 등의 React 내장 함수를 사용하고자 한다면 custom hook으로 사용해야한다.App.jsfunction App() { const [name, setName] = useLocalStorage(&quot;name&quot;, &quot;&quot;); return ( &amp;lt;input type=&quot;text&quot; value={name} onChange={(e) =&amp;gt; setName(e.target.value)} /&amp;gt; );}export default App;useLocalStorage.jsfunction getSavedValue(key, initialValue) { const savedValue = JSON.parse(localStorage.getItem(key)); if (savedValue) return savedValue; if (initialValue instanceof Function) return initialValue(); return initialValue;}export default function useLocalStorage(key, initialValue) { const [value, setValue] = useState(() =&amp;gt; { return getSavedValue(key, initialValue); }); useEffect(() =&amp;gt; { localStorage.setItem(key, JSON.stringify(value)); }, [value]); return [value, setValue];}ReferenceReact Hook Rule Example Code" }, { "title": "js slice splice", "url": "/posts/js-slice-splice/", "categories": "JS", "tags": "javascript", "date": "2022-06-21 23:00:00 +0900", "snippet": "Array.prototype.slice()원본배열은 수정하지 않고 begin - end 전까지의 복사본을 새로운 배열 객체로 반환slice does not alter the original array. It returns a shallow copy of elements from the original array.shallow copy return 함으로 객체배열 가공 사용에 적합하지 않음const animals = [&#39;ant&#39;, &#39;bison&#39;, &#39;camel&#39;, &#39;duck&#39;, &#39;elephant&#39;];console.log(animals.slice(2));// expected output: Array [&quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]console.log(animals.slice(2, 4));// expected output: Array [&quot;camel&quot;, &quot;duck&quot;]console.log(animals.slice(1, 5));// expected output: Array [&quot;bison&quot;, &quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]console.log(animals.slice(-2));// expected output: Array [&quot;duck&quot;, &quot;elephant&quot;]console.log(animals.slice(2, -1));// expected output: Array [&quot;camel&quot;, &quot;duck&quot;]console.log(animals.slice());// expected output: Array [&quot;ant&quot;, &quot;bison&quot;, &quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]Array.prototype.splice()원본 배열의 요소 삭제, 교체 혹은 추가splice(start, deleteCount, item1, item2, itemN) // start index부터 deleteCount(몇개) 지우고 item.. 추가 start: The index at which to start changing the array.deleteCount: An integer indicating the number of elements in the array to remove from start.item: The elements to add to the array, beginning from start.const months = [&#39;Jan&#39;, &#39;March&#39;, &#39;April&#39;, &#39;June&#39;];months.splice(1, 0, &#39;Feb&#39;);// inserts at index 1console.log(months);// expected output: Array [&quot;Jan&quot;, &quot;Feb&quot;, &quot;March&quot;, &quot;April&quot;, &quot;June&quot;]months.splice(4, 1, &#39;May&#39;);// replaces 1 element at index 4console.log(months);// expected output: Array [&quot;Jan&quot;, &quot;Feb&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;]Referencemozilla - slice mozilla - splice" }, { "title": "docker react deployment - travis ci, aws elastic beanstalk", "url": "/posts/docker-react-deployment/", "categories": "DOCKER", "tags": "docker, aws, travisci", "date": "2022-06-15 23:00:00 +0900", "snippet": "travis ciCI - Continuous Integrationgithub에서 코드 변경과 같은 특정 이벤트에 따라 자동으로 테스트 및 빌드, 배포 가능.대표적으로 Travis CI, Jenkins. https://travis-ci.com Sign in with github account Verifying email activate repositories register Plan (settings - plan - free trial) .travis.yml github push.travis.ymlsudo: required //관리자 권한 부여language: generic // language platformservices: - dockerbefore_install: - echo &quot;start creating an image with dockerfile&quot; - docker build -t milo/docker-react-app -f Dockerfile.dev .script: // test - docker run -e CI=true milo/docker-react-app npm run test -- --coverageafter_success: - echo &quot;Test Success&quot;(travis-cli)My Repositories - Currentaws - elastic beanstalkAWS Elastic Beanstalk는 Java, .NET, PHP, Node.js, Python, Ruby, Go 및 Docker를 사용하여 개발된 웹 애플리케이션 및 서비스를 Apache, Nginx, Passenger 및 IIS와 같은 친숙한 서버에서 손쉽게 배포하고 확장할 수 있는 서비스인스턴스, 데이터베이스, 보안그룹, 로드밸런서 등 다양한 서비스를 포함한 환경을 구성하고 관리해준다!aws - Elastic Beanstalk - create application application name: docker-react-app.travis.ymlsudo: requiredlanguage: genericservices: - dockerbefore_install: - echo &quot;start creating an image with dockerfile&quot; - docker build -t milo/docker-react-app -f Dockerfile.dev .script: - docker run -e CI=true milo/docker-react-app npm run test -- --coverageafter_success: - echo &quot;Test Success&quot;deploy: // add new edge: true provider: elasticbeanstalk // service ex)elasticbeanstalk, firebase, s3, ... region: ap-northeast-2 // aws region. seoul: ap-northeast-2 app: docker-react-app // app name env: DockerReactApp-env // UpperCamelCase(=PascalCase) of app name bucket_name: elasticbeanstalk-ap-northeast-2-879757627605 // s3 bucket name bucket-path: docker-react-app on: branch: main // sense which branch ex) main, dev, ...IAM user 생성IAM - 액세스 관리 - 사용자 - 사용자 추가 user : docker-react-user aws자격증명유형 : 액세스 키 - 프로그래밍 방식 권한: 기존정책직접연결 : AdministratorAccess-AWSElasticBeanstalk key, pass 복사travis-ci dashboard - More options : Settings - Environment Variables AWS_ACCESS_KEY, AWS_SECRET_ACCESS_KEY 입력.travis.yml에 추가access_key_id: $AWS_ACCESS_KEYsecret_access_key: $AWS_SECRET_ACCESS_KEYDockerFileFROM node:alpine as builderWORKDIR &#39;/usr/src/app&#39;COPY package.json .RUN npm installCOPY ./ ./RUN npm run buildFROM nginxEXPOSE 80 // 포트 설정 추가COPY --from=builder /usr/src/app/build /usr/share/nginx/htmlReferencehttps://docs.docker.com/network/overlay/#publish-ports" }, { "title": "docker react setting", "url": "/posts/docker-react-setting/", "categories": "DOCKER", "tags": "docker", "date": "2022-06-06 19:00:00 +0900", "snippet": "React docker dev circumstanceDockerfile.devFROM nodeWORKDIR /usr/src/appCOPY package.json ./RUN npm installCOPY ./ ./CMD [&quot;npm&quot;, &quot;run&quot;, &quot;start&quot;]build &amp;amp; execute$ docker build -f Dockerfile.dev -t milo/docker-react-app ./$ docker run -it -p 3000:3000 milo/docker-react-app코드 변경시 빌드할 필요없이 실행할 수 있도록 docker volume 사용법$ docker run -p 3000:3000 -v /usr/src/app/node_modules -v %cd%:/usr/src/app milo/docker-react-appdocker compose로 쉽게 실행하기docker-compose-dev.ymlversion: &quot;3&quot; // docker compose versionservices: // define containers react: // service name build: // build info context: . // location of files and folders dockerfile: Dockerfile.dev // docker file ports: // local : container - &quot;3000:3000&quot; volumes: - /usr/src/app/node_modules - ./:/usr/src/app environment: - CHOKIDAR_USEPOLLING=true // hot reloading stdin_open: true tests: build: context: . dockerfile: Dockerfile.dev volumes: - /usr/src/app/node_modules - ./:/usr/src/app command: [&quot;npm&quot;, &quot;run&quot;, &quot;test&quot;]테스트 진행법$ docker build -f Dockerfile.dev ./$ docker run -it milo/docker-react-app npm run testReact docker prod circumstance Builder Stage : build file create Run Stage : respond static files through NginxDockerfileFROM node:alpine as builder // notice that it&#39;s builder stage til next &#39;FROM&#39; by using &#39;as builder&#39;WORKDIR &#39;/usr/src/app&#39;COPY package.json .RUN npm installCOPY ./ ./RUN npm run buildFROM nginxCOPY --from=builder /usr/src/app/build /usr/share/nginx/html$ docker build -t milo/docker-react-app ./$ docker run -p 8080:80 milo/docker-react-appdocker-compose.ymlversion: &quot;3&quot;services: react: build: context: . dockerfile: Dockerfile ports: - &quot;80:80&quot; volumes: - /usr/src/app/node_modules - ./:/usr/src/app stdin_open: trueReferencehttps://docs.docker.com/network/overlay/#publish-ports" }, { "title": "Docker localhost에서 연결을 거부했습니다 에러 access denied", "url": "/posts/Docker-acess-denied-port/", "categories": "DOCKER, Error", "tags": "docker, access, port", "date": "2022-06-01 21:00:00 +0900", "snippet": "도커 실행후 웹브라우저로 접근시 access denied with localhost error 발생나의 경우는 포트 설정의 문제였다.도커 컨테이너 포트 포워딩 설정$ docker run -p &amp;lt;host port&amp;gt;:&amp;lt;container port&amp;gt;/&amp;lt;protocol&amp;gt; [IMAGE NAME] host port : 호스트 시스템 사용 포트 container port : 컨테이너 내의 포트 번호 protocol 생략시 기본 tcp 프로토콜로 설정$ -p 8080:80 // 호스트 8080포트 - 컨테이너 80포트 연결$ docker ps // PORTS : 0.0.0.0:8080-&amp;gt;80/tcpReferencehttps://docs.docker.com/network/overlay/#publish-ports" }, { "title": "docker image create", "url": "/posts/Docker-Image/", "categories": "DOCKER", "tags": "docker", "date": "2022-05-30 23:50:00 +0900", "snippet": "직접 도커 이미지 생성하기 도커파일(Dockerfile) 작성 : 컨테이너가 어떻게 행동해야 하는지에 대한 설정 도커파일에 입력한 명령어들이 도커 클라이언트에 전달 도커 클라이언트에 전달된 명령들을 도커 서버에서 처리후 도커 이미지 생성Dockerfile 생성 Base Image : Windows, MacOS, Linux … 애플리케이션 실행하는 데 필요한 파일들을 이미지 안에 내려받기 위한 명령어 명시 명령어 명시Dockerfile basic structure FROM 이미지 생성시 기반이 되는 이미지 레이어 명시 : 형식 ex) ubuntu:14.04 RUN 도커 이미지가 생성되기 전에 수행할 셸 명령어 CMD 컨테이너가 시작됐을 때 실행할 실행 파일 또는 셸 스크립트 이 명령어는 도커 파일 내에서 한 번만 사용 가능 Say Hello Image Simple example 만들기빌드\\react\\dockerfile-folder&amp;gt;docker build .Sending build context to Docker daemon 2.048kBStep 1/2 : FROM alpine ---&amp;gt; 0ac33e5f5afaStep 2/2 : CMD [ &quot;echo&quot;, &quot;hello&quot; ] ---&amp;gt; Running in 30dd11c5a82cRemoving intermediate container 30dd11c5a82c ---&amp;gt; b8e25d022de6Successfully built b8e25d022de6 빌드과정은 다음과 같다. 베이스 이미지를 가져온다. (alpine) 임시 컨테이너를 생성한다. alpine 이미지 내의 파일 snapshot을 컨테이너의 하드디스크로 복사. 실행할 명령어 ‘echo’, ‘hello’가 임시 컨테이너로 들어감. 임시 컨테이너 기반으로 실제 컨테이너 생성 실행\\react\\dockerfile-folder&amp;gt;docker run -it b8e25d022de6hellonaming Image\\react\\dockerfile-folder&amp;gt;docker build -t milo/hello:latest .\\react\\dockerfile-folder&amp;gt;docker run -it milo/hellohelloReference 따라하며 배우는 도커와 CI환경 -위키북스" }, { "title": "Docker Node Image 만들기", "url": "/posts/Docker-Node-Image/", "categories": "DOCKER", "tags": "docker", "date": "2022-05-24 00:50:00 +0900", "snippet": "도커를 이용해 Node.js 애플리케이션 만들기 Node.js application 만들기 도커 이미지 생성 COPY 하는 이유: 이미지 생성 과정에서 임시 컨테이너 안에 package.json이 없기때문에 npm install 과정에서 에러가 발생한다. 따라서 package.json을 컨테이너 안으로 넣어줘야 한다.빌드\\react\\nodejs-docker-app&amp;gt;docker build -t milo/node-app ./하지만 실행하면 server.js를 못찾는 에러 발생! package.json과 같이 server.js도 컨테이너 안으로 넣어줘야한다.빌드\\react\\nodejs-docker-app&amp;gt;docker build -t milo/node-app ./실행\\react\\nodejs-docker-app&amp;gt;docker run -p 5000:8080 milo/node-appserver listening... PORT Mapping(-p option) 로컬호스트 포트와 컨테이너 포트가 나뉘어 있어서 브라우저에서 애플리케이션에 접속하려면 포트 매핑 필요. $ docker run -p &amp;lt;localhost Port&amp;gt;:&amp;lt;Container Port&amp;gt; &amp;lt;Image name&amp;gt; 작업 directory 설정하기 COPY 한 파일들이 컨테이너 안의 최상단 폴더에 위치하게 되어 기존 파일을 덮어쓰게될 위험이 있다. 폴더가 복잡해진다. *directory설정 안했을 때 컨테이너 파일구조Dockerfile boot etc lib media node_modules package-lock.json proc run server.js sys usrbin dev home lib64 mnt opt package.json root sbin srv tmp var Dockerfile에 WORKDIR 추가FROM nodeWORKDIR /usr/src/appCOPY ./ ./RUN npm installCMD [ &quot;node&quot;, &quot;server.js&quot; ]코드 수정할 때마다 모든 종속성을 다시 다운받지 않도록 수정FROM nodeWORKDIR /usr/src/appCOPY package.json ./RUN npm installCOPY ./ ./CMD [ &quot;node&quot;, &quot;server.js&quot; ]RUN npm install 전 단계의 COPY에서 조금이라도 변화가 있다면 다시 내려받고, 아무런 변화가 없다면 캐시를 이용해 이과정을 생략한다.Docker volume 이용하기 파일들을 컨테이너로 복사하지않고 참조하도록 설정하는 것. COPY 사용시 코드가 변경될 때마다 복사, 빌드, 실행을 해야한다. volume을 이용하면 호스트 디렉터리의 파일을 참조하기때문에 COPY하여 이미지를 빌드할 필요가 없다. $ docker run -p 3000:8080 -v /usr/src/app/node_modules -v %cd%:/usr/src/app milo/node-app 뒤에 있는 -v의 의미: cd(절대경로) 뒤의 작업 directory를 참고해 애플리케이션 실행한다.앞에 있는 -v의 의미: node_modules는 호스트를 참조하지않는다. Reference 따라하며 배우는 도커와 CI환경 -위키북스" }, { "title": "Docker command", "url": "/posts/Docker-command/", "categories": "DOCKER", "tags": "docker", "date": "2022-05-23 00:50:00 +0900", "snippet": "기본적인 도커 클라이언트 명령어도커 이미지 내부 파일 구조 보기$docker run alpine lsUnable to find image &#39;alpine:latest&#39; locallylatest: Pulling from library/alpinedf9b9388f04a: Pull completeDigest: sha256:4edbd2beb5f78b1014028f4fbb99f3237d9561100b6881aabbf5acce2c4f9454Status: Downloaded newer image for alpine:latestbindevetchomelibmediamntoptprocrootrunsbinsrvsystmpusrvar alpine image file snapshot 안에는 ls 명령어를 사용할 수 있는 파일이 존재하기에 사용 가능.$ docker run hello-world lsdocker: Error response from daemon: failed to create shim: OCI runtime create failed: container_linux.go:380: starting container process caused: exec: &quot;ls&quot;: executable file not found in $PATH: unknown.현재 실행 중인 컨테이너 나열$ docker ps (-a : 중단된 컨테이너도 다 보기 옵션)CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESdd5b16cda50d alpine &quot;ping google.com&quot; 10 seconds ago Up 9 seconds frosty_agnesi컨테이너 생성 및 실행$ docker run = docker create + docker start$ docker start (-a : print results)컨테이너 멈추기$ docker stop : stop after being finished$ docker kill : stop immediately컨테이너 삭제$ docker rm$ docker rm `docker ps -a -q` : 중지된 모든 컨테이너 삭제$ docker rmi : 도커 이미지 같이 삭제$ docker system prune : 사용하지 않는 데이터 삭제실행중인 컨테이너에 명령어 전달$ docker exec (-it : 명령어 실행 후 계속 명령어 적을 수 있는 옵션)실행중인 컨테이너에서 터미널 사용$ docker exec -it sh$ docker run -it sh$ docker run -d // detached modeRun vs Start Docker Run: build a new container based on the image, Attached Mode Docker Start: restart already built one, Detached Mode(background running)Reference 따라하며 배우는 도커와 CI환경 -위키북스 udemy" }, { "title": "Docker basic", "url": "/posts/Docker-Intro/", "categories": "DOCKER", "tags": "docker", "date": "2022-05-22 17:50:00 +0900", "snippet": "도커를 사용하는 이유어떠한 프로그램을 내려받는 과정을 간단하게 만들기 위해서도커 사용 vs 도커 미사용 도커 미사용시(without Docker) : Installer download =&amp;gt; Excute Installer =&amp;gt; Install complete이러한 경우 Server, Package version, OS 에 따라 Error 발생 가능성 높음Docker? Container : 코드와 모든 종속성을 패키지화하여 응용 프로그램이 한 컴퓨팅 환경에서 다른 컴퓨팅 환경으로 빠르고 안정적으로 실행되도록 하는 소프트웨어의 표준 단위. Docker Image : 코드, 런타임, 시스템 도구, 시스템 라이브러리 및 설정과 같은 응용 프로그램을 실행하는 데 필요한 모든 것을 포함하는 가볍고 독립적이며 실행 가능한 소프트웨어 패키지. =&amp;gt; 도커 컨테이너는 도커 이미지로 만든다.=&amp;gt; 도커 이미지 안에는 응용 프로그램을 실행하는 데 필요한 모든 설정과 종속성이 필요하다.=&amp;gt; 도커 컨테이너를 도커 이미지의 인스턴스라고 부른다.=&amp;gt; 도커 이미지를 이용해 컨테이너를 생성하고 컨테이너를 이용해 프로그램을 실행한다. Docker is a software platform that allows you to build, test, and deploy applications quickly. Docker packages software into standardized units called containers that have everything the software needs to run including libraries, system tools, code, and runtime. Using Docker, you can quickly deploy and scale applications into any environment and know your code will run. - (aws) 도커(Docker)는 리눅스의 응용 프로그램들을 프로세스 격리 기술들을 사용해 컨테이너로 실행하고 관리하는 오픈 소스 프로젝트이다. - wikipediaInstallInstallcheck Install &amp;amp; version$docker versionServer: Docker Desktop 4.8.2 (79419) Engine: Version: 20.10.14 API version: 1.41 (minimum version 1.12) Go version: go1.16.15 Git commit: 87a90dc Built: Thu Mar 24 01:46:14 2022 OS/Arch: linux/amd64 Client가 mac or windows 여도, docker server는 linux vm 환경에서 실행됨 따라서 도커 컨테이너를 격리할 수 있는 Cgroup, namespace 사용 가능 hello world$docker run hello-worldUnable to find image &#39;hello-world:latest&#39; locallylatest: Pulling from library/hello-world2db29710123e: Pull completeDigest: sha256:80f31da1ac7b312ba29d65080fddf797dd76acfb870e677f390d5acba9741b17Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. 클라이언트에서 도커 서버로 요청 로컬에서 hello-world 이미지 있는지 확인 없기 때문에 ‘Unable to find image~~’ 출력 Docker hub에서 hello-world 이미지 가져오고 로컬에 보관 이미지 이용해서 컨테이너 생성 이미지에서 받은 설정이나 조건에 따라 프로그램 실행 Reference 따라하며 배우는 도커와 CI환경 -위키북스 https://aws.amazon.com/docker/ " }, { "title": "React-Node 채팅(Socket.io)", "url": "/posts/Socketio/", "categories": "NODE", "tags": "socketio", "date": "2022-05-14 21:07:00 +0900", "snippet": "Client(React)npm install socket.io-clientApp.jsimport io from &quot;socket.io-client&quot;;const socket = io.connect(&quot;http://localhost:3001&quot;);const sendMsg = (e) =&amp;gt; { e.preventDefault(); socket.emit(&quot;send message&quot;, { name: nickname, message: msg, chatroom }, setMsg(&quot;&quot;)); // 채팅 보내기 클릭시 emit으로 &quot;send message&quot;라는 이벤트 전송후 입력창 초기화};useEffect(() =&amp;gt; { socket.emit(&quot;init&quot;, chatroom); // 최초 로딩시 init 이라는 이벤트 전송}, []);useEffect(() =&amp;gt; { socket.on(&quot;receive message&quot;, (message) =&amp;gt; { // on으로 &#39;receive message&#39;라는 이벤트 수신 console.log(message); setMsgArr((msgArr) =&amp;gt; msgArr.concat(message)); });}, []);Server(Node)npm install socket.ioindex.jsconst express = require(&#39;express&#39;);const app = express();const http = require(&#39;http&#39;);const server = http.createServer(app);const io = socketio(server, { cors: { origin: &quot;http://localhost:3000&quot;, method: [&quot;GET&quot;, &quot;POST&quot;], },});io.on(&#39;connection&#39;, (socket) =&amp;gt; { // connection event console.log(&#39;a user connected&#39;); console.log(socket.id); // socket id auto generated socket.on(&#39;send message&#39;, (item) =&amp;gt; { // 메시지 보낸사람에게만 답장 보내기 io.to(socket.id).emit( &quot;receive message&quot;, &quot;hello&quot; ) }) socket.on(&#39;send message&#39;, (item) =&amp;gt; { // 보낸사람 포함 모두에게 보내기 io.emit( &quot;receive message&quot;, &quot;hello&quot; ) }) socket.broadcast.emit(&#39;hello&#39;); // 보낸사람 제외하고 모두에게 보내기});" }, { "title": "Scroll to the specific point", "url": "/posts/Scroll-to-the-point/", "categories": "REACT", "tags": "react", "date": "2022-04-13 09:50:00 +0900", "snippet": "Scroll 특정 포인트로 이동 2 method모든 페이지 최상단 이동은 최상단 이동 참고1. html basic function&amp;lt;Link to=&quot;/business#product&quot;&amp;gt; ‘/business’ -&amp;gt; page name ‘#product’ -&amp;gt; Id of point you want to goIf Link(react router dom) doesn’t work, try with a tag.2. react-router-hash-linkhttps://github.com/rafgraph/react-router-hash-link$npm i react-router-hash-linkimport { HashLink } from &#39;react-router-hash-link&#39;;...&amp;lt;HashLink to=&quot;/some/path#with-hash-fragment&quot;&amp;gt;Link to Hash Fragment&amp;lt;/HashLink&amp;gt;github을 보니 모바일 이동안되는 이슈? 확인해 볼 것" }, { "title": "Pm2-react", "url": "/posts/Pm2/", "categories": "ETC", "tags": "pm2", "date": "2022-04-11 01:25:00 +0900", "snippet": "무중단 배포를 위한 pm2 사용법(react, node)Installation$ npm install pm2 -gStart react $ pm2 --name (name) start npm -- start --watch node $ pm2 start (app.js) --name (name) --watch (name): project name–watch: optional. - automatically restart when it’s been modified List$ pm2 listMonit$ pm2 monitRestart$ pm2 restart main.jsStop$ pm2 stop main" }, { "title": "Scroll to the top(react-router-dom useLocation)", "url": "/posts/React-scroll-to-the-top/", "categories": "REACT", "tags": "react, useLocation", "date": "2022-04-07 21:07:00 +0900", "snippet": "Install react-router-domnpm i react-router-domcreate a file called ‘ScrollToTop’import { useEffect } from &#39;react&#39;;import { useLocation } from &#39;react-router-dom&#39;;const ScrollToTop = () =&amp;gt; { const {pathname} = useLocation(); useEffect(() =&amp;gt; { window.scrollTo(0,0); },[pathname])}Then, put in the routerfunction App() { return ( &amp;lt;BrowserRouter&amp;gt; &amp;lt;ScrollTotop /&amp;gt; &amp;lt;Routes&amp;gt; &amp;lt;Route element={&amp;lt;Layout /&amp;gt;}&amp;gt; &amp;lt;Route path=&quot;/&quot; element={&amp;lt;Home /&amp;gt;} /&amp;gt; &amp;lt;Route path=&quot;/about&quot; element={&amp;lt;About /&amp;gt;} /&amp;gt; &amp;lt;Route path=&quot;/business&quot; element={&amp;lt;Biz /&amp;gt;} /&amp;gt; &amp;lt;Route path=&quot;/career&quot; element={&amp;lt;Career /&amp;gt;} /&amp;gt; &amp;lt;/Route&amp;gt; &amp;lt;/Routes&amp;gt; &amp;lt;/BrowserRouter&amp;gt; );}What useLocation has hash: “#product” key: “g1vriyme” pathname: “/business” search: “” state: null [[Prototype]]: Object pathname: strings after domain search: strings after ‘?’ of pathname hash: strings after ‘#’ of pathname state: location object will be sent key: can find location object in history stack with" }, { "title": "vscode prettier quick setting", "url": "/posts/vscode-prettier-quick/", "categories": "ETC", "tags": "vscode, prettier", "date": "2022-04-05 23:25:00 +0900", "snippet": "빠르게 vscode에서 prettier 설정하는 법InstallationExtension에서 Prettier - Code formatter 설치Setting(ctrl + ,) ‘default formatter’ 검색 -&amp;gt; Editor:Default Formatter를 Prettier - Code formatter(없으면 ‘esbenp.prettier-vscode’)로 설정 ‘format on save’ 검색 -&amp;gt; Editor:Format On Save 체크 It works when you save" }, { "title": "React router dom V6", "url": "/posts/React-router-dom-v6/", "categories": "REACT", "tags": "react", "date": "2022-03-16 15:07:00 +0900", "snippet": "Installationnpm install react-router-dom@6Configuring Routesimport { BrowserRouter, Routes, Route } from &quot;react-router-dom&quot;;function App() { return ( &amp;lt;BrowserRouter&amp;gt; &amp;lt;Routes&amp;gt; &amp;lt;Route path=&quot;/&quot; element={&amp;lt;Home /&amp;gt;} /&amp;gt; &amp;lt;Route path=&quot;chat&quot; element={&amp;lt;Chat /&amp;gt;} /&amp;gt; &amp;lt;/Routes&amp;gt; &amp;lt;/BrowserRouter&amp;gt; );}Navigationimport { Link } from &quot;react-router-dom&quot;;function Home() { return ( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;Home&amp;lt;/h1&amp;gt; &amp;lt;nav&amp;gt; &amp;lt;Link to=&quot;/&quot;&amp;gt;Home&amp;lt;/Link&amp;gt; |{&quot; &quot;} &amp;lt;Link to=&quot;about&quot;&amp;gt;About&amp;lt;/Link&amp;gt; &amp;lt;/nav&amp;gt; &amp;lt;/div&amp;gt; );}import { useNavigate } from &quot;react-router-dom&quot;;function Invoices() { let navigate = useNavigate(); return ( &amp;lt;div&amp;gt; &amp;lt;NewInvoiceForm onSubmit={async (event) =&amp;gt; { let newInvoice = await createInvoice( event.target ); navigate(`/invoices/${newInvoice.id}`); }} /&amp;gt; &amp;lt;/div&amp;gt; );}URL parametersimport { Routes, Route, useParams } from &quot;react-router-dom&quot;;function App() { return ( &amp;lt;Routes&amp;gt; &amp;lt;Route path=&quot;invoices/:invoiceId&quot; element={&amp;lt;Invoice /&amp;gt;} /&amp;gt; &amp;lt;/Routes&amp;gt; );}function Invoice() { let params = useParams(); return &amp;lt;h1&amp;gt;Invoice {params.invoiceId}&amp;lt;/h1&amp;gt;;}Not Found Routesfunction App() { return ( &amp;lt;Routes&amp;gt; &amp;lt;Route path=&quot;/&quot; element={&amp;lt;Home /&amp;gt;} /&amp;gt; &amp;lt;Route path=&quot;dashboard&quot; element={&amp;lt;Dashboard /&amp;gt;} /&amp;gt; &amp;lt;Route path=&quot;*&quot; element={&amp;lt;NotFound /&amp;gt;} /&amp;gt; &amp;lt;/Routes&amp;gt; );}Nested Route 중첩 라우팅Common layout공통 레이아웃의 경우 기존 {children} 과 같이 썼다면,Outlet을 import하고 children 대신 쓰면 된다.Method 1.&amp;lt;BrowserRouter&amp;gt; &amp;lt;Routes&amp;gt; &amp;lt;Route path=&quot;/&quot; element={&amp;lt;App /&amp;gt;}&amp;gt; &amp;lt;Route path=&quot;expenses&quot; element={&amp;lt;Expenses /&amp;gt;} /&amp;gt; &amp;lt;Route path=&quot;invoices&quot; element={&amp;lt;Invoices /&amp;gt;} /&amp;gt; &amp;lt;/Route&amp;gt; &amp;lt;/Routes&amp;gt;&amp;lt;/BrowserRouter&amp;gt;//App.jsimport { Outlet, Link } from &quot;react-router-dom&quot;;export default function App() { return ( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;Bookkeeper&amp;lt;/h1&amp;gt; &amp;lt;nav style= &amp;gt; &amp;lt;Link to=&quot;/invoices&quot;&amp;gt;Invoices&amp;lt;/Link&amp;gt; |{&quot; &quot;} &amp;lt;Link to=&quot;/expenses&quot;&amp;gt;Expenses&amp;lt;/Link&amp;gt; &amp;lt;/nav&amp;gt; &amp;lt;Outlet /&amp;gt; &amp;lt;/div&amp;gt; );}Method 2.const App = () =&amp;gt; { return ( &amp;lt;BrowserRouter&amp;gt; &amp;lt;Routes&amp;gt; &amp;lt;Route path=&quot;/workspace/*&quot; element={&amp;lt;Workspace /&amp;gt;} /&amp;gt; &amp;lt;/Routes&amp;gt; &amp;lt;/BrowserRouter&amp;gt; );};const Workspace= () =&amp;gt; { return ( &amp;lt;Routes&amp;gt; &amp;lt;Route path=&quot;channel&quot; element={&amp;lt;Channel /&amp;gt;} /&amp;gt; &amp;lt;Route path=&quot;dm&quot; element={&amp;lt;DirectMessage /&amp;gt;} /&amp;gt; &amp;lt;/Routes&amp;gt; );};" }, { "title": "공공데이터포털 Service key is not registered error", "url": "/posts/Service-key-is-not-registered-error/", "categories": "ETC", "tags": "error", "date": "2022-03-07 21:07:00 +0900", "snippet": "SERVICE KEY IS NOT REGISTERED ERROR공공데이터포털 활용 신청 후 1시간 ~ 최대 48시간(영업일기준) 소요된다. 나는 48시간이 지나도 result code 99….. 오류신고 문의 해도 제대로 등록돼 있다고 답변 받음;;인증키 재발급 받으니 잘된다….." }, { "title": "ES6 Range(lazy)", "url": "/posts/ES6-Range/", "categories": "JS", "tags": "javascript, es6", "date": "2022-03-01 21:07:00 +0900", "snippet": "rangeconst range = l =&amp;gt; { let i = -1; let res = []; while(++i &amp;lt; l) { res.push(i); } return res;};var list = range(4);log(list); //[0,1,2,3]lazy rangeconst L = {};L.range = function *(l) { let i = -1; while (++i &amp;lt; l) { yield i; }};var list = L.range(4);log(list); // (nothing)log(list.next()); //{value: 0, done: false}log(list.next()); //{value: 1, done: false}log(list.next()); //{value: 2, done: false}log(list.next()); //{value: 3, done: false}L.range의 경우 실제 iterate 돌기 전까지는 작동하지 않으며 log(list) 부분에서는 배열형태도 아닌, 평가되지 않는 상태임.Reference https://www.inflearn.com/course/functional-es6" }, { "title": "ES6 반복문 Loops and iteration", "url": "/posts/ES6-iteration/", "categories": "JS", "tags": "javascript, es6, loops, iteration", "date": "2022-02-26 21:07:00 +0900", "snippet": "for…of The for…of statement creates a loop iterating over iterable objects, including: built-in String, Array, array-like objects (e.g., arguments or NodeList), TypedArray, Map, Set, and user-defined iterables.for…of 는 반복가능한 객체(Array, Map, Set, String, TypedArray 등)를 반복한다.사용법const arr = [1,2,3];for(item of arr){ console.log(item);}원리The iterator protocol The iterator protocol defines a standard way to produce a sequence of values (either finite or infinite), and potentially a return value when all values have been generated.순회가능한 객체가 되기 위한 규약Iterable = 순회 가능한 객체 : Symbol.iterator 라는 *symbol을 속성으로 가지고 있으며, 이터레이터 객체를 반환하는 객체. Symbol은 Boolean, null, undefined, Number, String, Object에 이어 새로 추가된 타입으로, 변경 불가능한 원시 타입의 값. 주로 이름의 충돌 위험이 없는 유일한 객체의 프로퍼티 키를 만들기 위해 사용된다.Iterator = 두 개의 속성(value, done)을 반환하는 next() 메소드를 사용하여 객체의 Iterator protocol을 구현함.위의 arr 안에는 Symbol(Symbol.iterator) 라는 symbol 속성을 가지고 있다.arr[Symbol.iterator] //ƒ values() { [native code] }const iter = arr[Symbol.iterator](); //iter라는 iterator 생성iter.next(); //{value: 1, done: false}iter.next(); //{value: 2, done: false}iter.next(); //{value: 3, done: false}iter.next(); //{value: undefined, done: true}Sequence의 마지막 값이 산출되면 done 값은 true가 된다.전개연산자const a = [1, 2];log([...a, ...[3,4]]); // [1,2,3,4]제너레이터 이터레이터이자 이터러블을 생성하는 함수function *gen() { yield 1; yield 2; yield 3;}let iter = gen();log(iter.next()); //{value: 1, done: false}log(iter.next()); //{value: 2, done: false}log(iter.next()); //{value: 3, done: false}log(iter.next()); //{value: undefined, done: true}Reference https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for…of https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Iteration_protocols https://www.inflearn.com/course/functional-es6" }, { "title": "클로저 closure", "url": "/posts/Closure/", "categories": "JS", "tags": "javascript, closure", "date": "2022-02-23 18:20:00 +0900", "snippet": "클로저(Closure) A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment).내부함수와 LexicalEnvironment의 조합.INNER FUNC BenvironmentRecord**outerEnvironmentReference**CONTEXT A**environmentRecord**outerEnvironmentReferenceCONTEXT A에서 선언한 변수를 내부함수 B에서 참조할 경우에 발생하는 특별한 현상var outer = function () { var a = 1; var inner = function () { return ++a; }; return inner;}var outer2 = outer();console.log(outer2()); // 2console.log(outer2()); // 3 전역-environmentRecord : { outer: func, outer2: undefined }outer executed; outer - environmentRecord: { a: 1, inner: func }outer - outerEnvironmentReference: { outer: func }전역 - environmentRecord : { outer: func, outer2: undefined }outer finished; outer - environmentRecord: { a: 1 }전역 - environmentRecord : { outer: func, outer2: inner }outer는 outer2에 의해 언제든지 다시 호출 될 수 있기 때문에 outer context는 종료 되었지만 a의 참조카운트가 0이 아니기 때문에 없어지지 않는다. 이 상태에서 console로 실행하게 되면 inner함수는 outerEnvironmentReference를 찾게 되고 남아있던 a에 +1을 한 2가 나온다.outer2에 다른 값을 대입하면 참조카운트가 0이 되면서 GC대상이 되어 사라진다.CONTEXT A에서 선언한 변수a를 참조하는 내부함수 B를 A의 외부로 전달할 경우, A가 종료된 이후에도 a가 사라지지 않는 현상!Reference https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures https://www.inflearn.com/course/%ED%95%B5%EC%8B%AC%EA%B0%9C%EB%85%90-javascript-flow" }, { "title": "리액트 사용 이유 Why is React better than jQuery", "url": "/posts/Why-is-React-better-than-jQuery/", "categories": "REACT", "tags": "react, jquery", "date": "2022-02-18 18:20:00 +0900", "snippet": "React vs jQuerySpeed One of the biggest things that React has going for it is the use of the Virtual DOM (Document Object Model) instead of the traditional DOM. While jQuery works with the DOM directly, React uses the virtual DOM which is what makes React so much faster.업데이트가 필요할 때 jQuery는 직접적으로 DOM을 수정하는 반면, React는 Virtual DOM을 이용한다. 직접적으로 수정하는 경우 DOM TREE의 최상단으로부터 update가 이루어지는 반면, Virtual DOM은 변경 전 DOM을 Screenshot처럼 기억해 두었다가 변경된 부분만 변경이 가능하다. 따라서 업데이트가 빈번할수록, DOM TREE 사이즈가 클수록 성능차이는 커지게 된다.아래 영상을 보면 React의 Virtual DOM의 컨셉을 쉽게 이해할 수 있다.VisibilityjQuery는 프로젝트가 복잡하고 커질수록 유지보수가 힘들어지는 면이 있다.Reference https://www.educative.io/edpresso/jquery-vs-react https://javascript.plainenglish.io/why-you-should-use-react-instead-of-jquery-d68b5b129bbb" }, { "title": "쿠키가 동작 안할때 확인해야 할 것들 when cookie doesn&#39;t work", "url": "/posts/When-Cookie-doesn't-work/", "categories": "WEB", "tags": "web, cookie", "date": "2022-02-16 22:20:00 +0900", "snippet": "쿠키가 제대로 작동하지 않을때 체크해야 할 리스트를 정리해 보았다.1. withCredentials XMLHttpRequest.withCredentials property is a boolean value that indicates &amp;gt;whether or not cross-site Access-Control requests should be made using &amp;gt;credentials such as cookies, authorization headers or TLS client &amp;gt;certificates.Credendial. 말그대로 자격을 뜻하며 다른 origin 간에 자격증명(cookie 등을) 전송 할 것인지를 boolean 설정. Client, Server의 withCredentials를 true로 설정하면 쿠키 전송 가능.다만, Credential is not supported if the CORS header ‘Access-Control-Allow-Origin’ is ‘*’.‘Access-Control-Allow-Origin’ 을 *가 아닌 특정 도메인을 넣어줘야 한다.2. Domain option The Domain attribute specifies which hosts can receive a cookie. If unspecified, the attribute defaults to the same host that set the cookie, excluding subdomains. If Domain is specified, then subdomains are always included. Therefore, specifying Domain is less restrictive than omitting it. However, it can be helpful when subdomains need to share information about a user.Domain attribute를 설정해야 sub domain에서 쿠키 사용이 가능하다. ex) Domain = myportfolio.com -&amp;gt; api.myportfolio.com에서 access ㅇ3. Path option The Path attribute indicates a URL path that must exist in the requested URL in order to send the Cookie header. The %x2F (“/”) character is considered a directory separator, and subdirectories match as well.설정된 경로 및 하위 경로에 있는 페이지에서 접근 가능. ex) Path=/user -&amp;gt; /user/login, /user/logout, …Path=/ 로 설정할 시 제한 x4. SameSite The SameSite attribute of the Set-Cookie HTTP response header allows you to declare if your cookie should be restricted to a first-party or same-site context.쿠키의 공유를 same site로 제한 할 지 설정. Lax(Chrome Default) Cookies are not sent on normal cross-site subrequests (for example to load images or frames into a third party site), but are sent when a user is navigating to the origin site (i.e., when following a link). 링크를 따라 들어 오는 등의 경로를 제외하고는 다른 도메인 쿠키 접근 불가. same site의 기준은?도메인 접미사와 바로 앞의 도메인 부분이 결합된 것www.web.dev와 static.web.dev은 same site. galaxy.github.io와 apple.github.io은 same site X. github.io 가 접미사이기 때문이다. public suffix list는 따로 문서화 되어있다. (https://publicsuffix.org/list/)Reference https://web.dev/samesite-cookies-explained/#explicitly-state-cookie-usage-with-the-samesite-attribute https://ko.javascript.info/cookie https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies" }, { "title": "Ubuntu Node", "url": "/posts/Ubuntu-Node/", "categories": "AWS, Ubuntu", "tags": "ubuntu, node", "date": "2022-02-15 11:30:00 +0900", "snippet": "Node Install 우분투18 노드 설치$curl -sL https://deb.nodesource.com/setup_16.x | sudo bash -E -$sudo apt install -y nodejs 원하는 버전으로 setup_ 부분 숫자만 변경" }, { "title": "Favicon 간편하게 만들기", "url": "/posts/Favicon-maker/", "categories": "ETC", "tags": "favicon", "date": "2022-02-15 11:30:00 +0900", "snippet": "https://favicon.io/favicon-generator/" }, { "title": "EC2 ubuntu port redirect 포트 리다이렉트 포워딩", "url": "/posts/Ubuntu-Port-redirect/", "categories": "AWS, Ubuntu", "tags": "ubuntu, port", "date": "2022-02-12 10:40:00 +0900", "snippet": "Port Redirect (ex. 80 =&amp;gt; 3000)$sudo iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 3000사용중인 Port redirect list$sudo iptables -t nat -L --line-numbersPort Redirect 삭제$sudo iptables -t nat -D PREROUTING 번호 Redirect List 조회 후 해당 번호로 삭제" }, { "title": "EC2 ubuntu18 nginx", "url": "/posts/Ubuntu-Nginx/", "categories": "AWS, Ubuntu", "tags": "ubuntu, nginx", "date": "2022-02-12 10:40:00 +0900", "snippet": "Nginx 설치패키지 목록 업데이트 &amp;amp; nginx 설치$sudo apt update$sudo apt install nginxNginx 전체 삭제$sudo apt-get purge nginx nginx-commonNginx 시작$sudo systemctl start nginxNginx 재시작$sudo systemctl restart nginxNginx 중지$sudo systemctl stop nginxNginx 설정 test$sudo nginx -tNginx 경로모든 Nginx 구성 파일 위치/etc/nginx기본 구성 파일 위치/etc/nginx/nginx.conf" }, { "title": "WARNING REMOTE HOST IDENTIFICATION HAS CHANGED!", "url": "/posts/REMOTE-HOST-IDENTIFICATION-HAS-CHANGED/", "categories": "AWS, Error", "tags": "aws, ssh", "date": "2022-02-12 10:40:00 +0900", "snippet": "원인IP는 동일하나 목적지 서버 장비 등이 바뀌었을 때 발생해결법ssh-keygen -R [host] -R hostname Removes all keys belonging to hostname from a known_hosts file. This option is useful to delete hashed hosts (see the -H option above)." }, { "title": "Creating an optimized production build...", "url": "/posts/Creating-an-optimized-production-build/", "categories": "AWS, Error", "tags": "ec2", "date": "2022-02-12 10:40:00 +0900", "snippet": "빌드시 Creating an optimized production build… 에서 Freeze원인메모리 부족… 프리티어의 비애해결법 GENERATE_SOURCEMAP option off &quot;build&quot;: GENERATE_SOURCEMAP=false npx react-scripts build 디버깅 정보 불포함하여 빌드 됨 Memory swap 1.sudo dd if=/dev/zero of=/mnt/swapfile bs=1M count=2048 2.sudo mkswap /mnt/swapfile 3.sudo swapon /mnt/swapfile 순서대로 명령어 실행 메모리의 부족한 부분을 디스크의 일부를 사용하여 대신 사용 사용시 속도가 느려진다는 단점 swap 해제 1.sudo dd if=/dev/zero of=/mnt/swapfile bs=1M count=2048 2.sudo mkswap /mnt/swapfile 3.sudo swapon /mnt/swapfile 출처: https://progdev.tistory.com/26 [플머의 개발 연구소]" } ]
