<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="ownership of rust(1)" /><meta property="og:locale" content="en" /><meta name="description" content="Ownership Ownership이란 Rust만의 유니크한 특성이며, gc없이도 안전하게 메모리를 사용하게 해주는 개념이다. What is Ownership? Ownership은 Rust가 어떻게 memory를 관리할 지 통제하는 규칙들의 set이다. 어떤 언어들은 garbage collection이 주기적으로 더이상 사용하지 않는 메모리들을 관리해주고(Java, JS, Python, GO) 어떤 언어들은 프로그래머가 직접 할당과 해제를 하여 메모리를 관리해야 한다.(C, C++) Rust는 그 외의 방식: compiler가 체크하는 규칙들의 set인 ownership 시스템에 의해 관리된다. 규칙이 위배된다면, compile되지 않는다! The Stack and the Heap 대부분의 언어들은 작업할 때 stack과 heap에 대해 신경쓰지 않아도 된다. 하지만 Rust는 value가 stack or heap 어디에 있는 값인지에 따라 다르게 작동한다. 따라서 여기서 간단하게 짚고 넘어가겠다. Stack Last in, First out (접시쌓기와 같다) data는 known, fixed size fast Heap Allocator가 heap에서 충분한 자리를 찾고 pointer을 return(Allocating: 레스토랑의 자리 안내와 같다) Compile시 unknown size =&gt; Heap slow more work Ownership Rules 다음의 규칙들은 기억하고 예제를 봅시다! Rust에서 각 Value는 owner가 있다. 한 번에 한 owner만 있을 수 있다. owner가 scope를 벗어나면 value는 drop된다. Variable Scope 1 2 3 4 5 6 7 8 fn main() { { // s is not valid here, it’s not yet declared let s = &quot;hello&quot;; // s is valid from this point forward // do stuff with s } // this scope is now over, and s is no longer valid } 이 코드에서 중요한 사실 두가지: scope 안에서 s는 valid하다. scope를 벗어나면 no longer valid하다. The String Type 위의 예제는 string literals로 많은 상황에 맞지 않고, 변형불가능하다. 우리는 String을 사용하여 unknown한 값을 저장할 수 있다. 1 let s = String::from(&quot;hello&quot;); 변형 또한 가능하다. 1 2 3 4 5 let mut s = String::from(&quot;hello&quot;); s.push_str(&quot;, world!&quot;); // push_str() appends a literal to a String println!(&quot;{}&quot;, s); // This will print `hello, world!` 왜 String은 변형 가능하지만 literals는 불가능할까? 이는 두 타입의 메모리 저장 방식이 다르기 때문이다. Memory and Allocation 변형가능하며 늘어날 수 있는 text를 위해서 우리는 heap에 메모리를 할당해야 한다. 이것은 곧 runtime에 allocator에 의해 메모리가 요청되어야 한다. 우리가 해당 String에 관하여 업무가 끝났을 때 이 메모리는 allocator에게 반환 되어야 한다. 을 의미한다. 첫번째 부분은 String::from 을 호출 함으로 해결된다. 두번째 부분이 쉽지않다. GC가 존재하지않으니 우리가 직접 메모리를 관리해야 한다. 너무 빨리 정리하면 invalid해지고, 두번 실행해도 bug이다. 우리는 딱 한번의 allocate와 딱 한번의 free로 매치해야 한다. 변수가 해당 scope 밖으로 나가면 Rust는 ‘drop’이라는 함수를 call하여 메모리를 정리한다. Variables and Data interacting with Move 1 2 let s1 = String::from(&quot;hello&quot;); let s2 = s1; 해당 코드는 s2에 s1의 value를 단순히 복사할 것 같지만 그렇지 않다. 왼쪽의 ptr, len, capacity의 정보들은 stack에 저장되고, 우측의 contents는 heap 메모리에 저장된다. s2에 s1을 할당할 때, contents가 아닌 해당 정보가 담긴 stack의 값만 복사된다.(아래의 사진) 따라서 두개의 포인터가 같은 곳을 바라보고 있게 된다는 뜻인데, 앞서 말했듯 scope를 벗어나면 free 시킬 것이고 그렇다면 두개의 포인터 모두 같은 메모리에 대해 중복으로 처리를 시도하게 된다. 이는 한번 allocate - 한번 free를 위해된다. 이러한 메모리 safety를 위해서 rust는 let s2 = s1 실행시 s1은 더이상 valid하지 않다고 여긴다. 1 2 3 4 let s1 = String::from(&quot;hello&quot;); let s2 = s1; println!(&quot;{}, world!&quot;, s1); // Error! 이는 다른 언어의 shallow copy, deep copy의 원리와 비슷하다. 또한 이 경우 우리는 s1에서 s2로 이동했다고 표현한다. (s1 invalid, scope 벗어날 시 s2는 memory free 실행) Variables and Data interacting with Clone 위와는 달리 heap data까지 deep copy를 하고 싶으면 우리는 Clone을 사용할 수있다. 1 2 3 4 let s1 = String::from(&quot;hello&quot;); let s2 = s1.clone(); println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2); Stack-Only Data: Copy 1 2 3 4 let x = 5; let y = x; println!(&quot;x = {}, y = {}&quot;, x, y); 다음과 같은 integer값은 clone 필요없이 잘 작동한다. integers 같은 값은 정해진 size이며 전체 값이 stack에 저장된다. 따라서 실제값을 copy하는 데에도 굉장히 빠르다. Rust는 ‘Copy’라는 special annotation을 갖고있는데, 만약 type이 Copy를 implements한다면 위 예제의 ‘이동’이 발생하지않고 평범하게 copy되고 할당 후에도 계속 valid하다. Copy를 implements하는 타입 목록은 다음과 같다. All the integer types. The Boolean type All the floating-point types The character type Tuples, if they only contain types that also implement Copy.(둘다 Copy를 implement하는 경우) Ownership and Functions 함수에 값을 전달하는 것도 변수에 초기화 하는 것과 비슷하다. move or copy. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 fn main() { let s = String::from(&quot;hello&quot;); // s comes into scope takes_ownership(s); // s&#39;s value moves into the function... // ... and so is no longer valid here let x = 5; // x comes into scope makes_copy(x); // x would move into the function, // but i32 is Copy, so it&#39;s okay to still // use x afterward } // Here, x goes out of scope, then s. But because s&#39;s value was moved, nothing // special happens. fn takes_ownership(some_string: String) { // some_string comes into scope println!(&quot;{}&quot;, some_string); } // Here, some_string goes out of scope and `drop` is called. The backing // memory is freed. fn makes_copy(some_integer: i32) { // some_integer comes into scope println!(&quot;{}&quot;, some_integer); } // Here, some_integer goes out of scope. Nothing special happens. takes_ownership(s); 이후에 s를 호출하면 compile-time Error! Return Values and Scope 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 fn main() { let s1 = gives_ownership(); // gives_ownership moves its return // value into s1 let s2 = String::from(&quot;hello&quot;); // s2 comes into scope let s3 = takes_and_gives_back(s2); // s2 is moved into // takes_and_gives_back, which also // moves its return value into s3 } // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing // happens. s1 goes out of scope and is dropped. fn gives_ownership() -&gt; String { // gives_ownership will move its // return value into the function // that calls it let some_string = String::from(&quot;yours&quot;); // some_string comes into scope some_string // some_string is returned and // moves out to the calling // function } // This function takes a String and returns one fn takes_and_gives_back(a_string: String) -&gt; String { // a_string comes into // scope a_string // a_string is returned and moves out to the calling function } 함수를 사용하면서 소유권을 갖는 것과 반납하는 것은 매우 성가시다. Rust에서는 이를 위해서 references를 제공한다! Ref: https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" /><meta property="og:description" content="Ownership Ownership이란 Rust만의 유니크한 특성이며, gc없이도 안전하게 메모리를 사용하게 해주는 개념이다. What is Ownership? Ownership은 Rust가 어떻게 memory를 관리할 지 통제하는 규칙들의 set이다. 어떤 언어들은 garbage collection이 주기적으로 더이상 사용하지 않는 메모리들을 관리해주고(Java, JS, Python, GO) 어떤 언어들은 프로그래머가 직접 할당과 해제를 하여 메모리를 관리해야 한다.(C, C++) Rust는 그 외의 방식: compiler가 체크하는 규칙들의 set인 ownership 시스템에 의해 관리된다. 규칙이 위배된다면, compile되지 않는다! The Stack and the Heap 대부분의 언어들은 작업할 때 stack과 heap에 대해 신경쓰지 않아도 된다. 하지만 Rust는 value가 stack or heap 어디에 있는 값인지에 따라 다르게 작동한다. 따라서 여기서 간단하게 짚고 넘어가겠다. Stack Last in, First out (접시쌓기와 같다) data는 known, fixed size fast Heap Allocator가 heap에서 충분한 자리를 찾고 pointer을 return(Allocating: 레스토랑의 자리 안내와 같다) Compile시 unknown size =&gt; Heap slow more work Ownership Rules 다음의 규칙들은 기억하고 예제를 봅시다! Rust에서 각 Value는 owner가 있다. 한 번에 한 owner만 있을 수 있다. owner가 scope를 벗어나면 value는 drop된다. Variable Scope 1 2 3 4 5 6 7 8 fn main() { { // s is not valid here, it’s not yet declared let s = &quot;hello&quot;; // s is valid from this point forward // do stuff with s } // this scope is now over, and s is no longer valid } 이 코드에서 중요한 사실 두가지: scope 안에서 s는 valid하다. scope를 벗어나면 no longer valid하다. The String Type 위의 예제는 string literals로 많은 상황에 맞지 않고, 변형불가능하다. 우리는 String을 사용하여 unknown한 값을 저장할 수 있다. 1 let s = String::from(&quot;hello&quot;); 변형 또한 가능하다. 1 2 3 4 5 let mut s = String::from(&quot;hello&quot;); s.push_str(&quot;, world!&quot;); // push_str() appends a literal to a String println!(&quot;{}&quot;, s); // This will print `hello, world!` 왜 String은 변형 가능하지만 literals는 불가능할까? 이는 두 타입의 메모리 저장 방식이 다르기 때문이다. Memory and Allocation 변형가능하며 늘어날 수 있는 text를 위해서 우리는 heap에 메모리를 할당해야 한다. 이것은 곧 runtime에 allocator에 의해 메모리가 요청되어야 한다. 우리가 해당 String에 관하여 업무가 끝났을 때 이 메모리는 allocator에게 반환 되어야 한다. 을 의미한다. 첫번째 부분은 String::from 을 호출 함으로 해결된다. 두번째 부분이 쉽지않다. GC가 존재하지않으니 우리가 직접 메모리를 관리해야 한다. 너무 빨리 정리하면 invalid해지고, 두번 실행해도 bug이다. 우리는 딱 한번의 allocate와 딱 한번의 free로 매치해야 한다. 변수가 해당 scope 밖으로 나가면 Rust는 ‘drop’이라는 함수를 call하여 메모리를 정리한다. Variables and Data interacting with Move 1 2 let s1 = String::from(&quot;hello&quot;); let s2 = s1; 해당 코드는 s2에 s1의 value를 단순히 복사할 것 같지만 그렇지 않다. 왼쪽의 ptr, len, capacity의 정보들은 stack에 저장되고, 우측의 contents는 heap 메모리에 저장된다. s2에 s1을 할당할 때, contents가 아닌 해당 정보가 담긴 stack의 값만 복사된다.(아래의 사진) 따라서 두개의 포인터가 같은 곳을 바라보고 있게 된다는 뜻인데, 앞서 말했듯 scope를 벗어나면 free 시킬 것이고 그렇다면 두개의 포인터 모두 같은 메모리에 대해 중복으로 처리를 시도하게 된다. 이는 한번 allocate - 한번 free를 위해된다. 이러한 메모리 safety를 위해서 rust는 let s2 = s1 실행시 s1은 더이상 valid하지 않다고 여긴다. 1 2 3 4 let s1 = String::from(&quot;hello&quot;); let s2 = s1; println!(&quot;{}, world!&quot;, s1); // Error! 이는 다른 언어의 shallow copy, deep copy의 원리와 비슷하다. 또한 이 경우 우리는 s1에서 s2로 이동했다고 표현한다. (s1 invalid, scope 벗어날 시 s2는 memory free 실행) Variables and Data interacting with Clone 위와는 달리 heap data까지 deep copy를 하고 싶으면 우리는 Clone을 사용할 수있다. 1 2 3 4 let s1 = String::from(&quot;hello&quot;); let s2 = s1.clone(); println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2); Stack-Only Data: Copy 1 2 3 4 let x = 5; let y = x; println!(&quot;x = {}, y = {}&quot;, x, y); 다음과 같은 integer값은 clone 필요없이 잘 작동한다. integers 같은 값은 정해진 size이며 전체 값이 stack에 저장된다. 따라서 실제값을 copy하는 데에도 굉장히 빠르다. Rust는 ‘Copy’라는 special annotation을 갖고있는데, 만약 type이 Copy를 implements한다면 위 예제의 ‘이동’이 발생하지않고 평범하게 copy되고 할당 후에도 계속 valid하다. Copy를 implements하는 타입 목록은 다음과 같다. All the integer types. The Boolean type All the floating-point types The character type Tuples, if they only contain types that also implement Copy.(둘다 Copy를 implement하는 경우) Ownership and Functions 함수에 값을 전달하는 것도 변수에 초기화 하는 것과 비슷하다. move or copy. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 fn main() { let s = String::from(&quot;hello&quot;); // s comes into scope takes_ownership(s); // s&#39;s value moves into the function... // ... and so is no longer valid here let x = 5; // x comes into scope makes_copy(x); // x would move into the function, // but i32 is Copy, so it&#39;s okay to still // use x afterward } // Here, x goes out of scope, then s. But because s&#39;s value was moved, nothing // special happens. fn takes_ownership(some_string: String) { // some_string comes into scope println!(&quot;{}&quot;, some_string); } // Here, some_string goes out of scope and `drop` is called. The backing // memory is freed. fn makes_copy(some_integer: i32) { // some_integer comes into scope println!(&quot;{}&quot;, some_integer); } // Here, some_integer goes out of scope. Nothing special happens. takes_ownership(s); 이후에 s를 호출하면 compile-time Error! Return Values and Scope 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 fn main() { let s1 = gives_ownership(); // gives_ownership moves its return // value into s1 let s2 = String::from(&quot;hello&quot;); // s2 comes into scope let s3 = takes_and_gives_back(s2); // s2 is moved into // takes_and_gives_back, which also // moves its return value into s3 } // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing // happens. s1 goes out of scope and is dropped. fn gives_ownership() -&gt; String { // gives_ownership will move its // return value into the function // that calls it let some_string = String::from(&quot;yours&quot;); // some_string comes into scope some_string // some_string is returned and // moves out to the calling // function } // This function takes a String and returns one fn takes_and_gives_back(a_string: String) -&gt; String { // a_string comes into // scope a_string // a_string is returned and moves out to the calling function } 함수를 사용하면서 소유권을 갖는 것과 반납하는 것은 매우 성가시다. Rust에서는 이를 위해서 references를 제공한다! Ref: https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" /><link rel="canonical" href="https://milo-oh-taek.github.io//posts/ownership-of-rust(1)/" /><meta property="og:url" content="https://milo-oh-taek.github.io//posts/ownership-of-rust(1)/" /><meta property="og:site_name" content="Hyeontaek Oh" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-01-03T12:40:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="ownership of rust(1)" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-01-03T12:40:00+09:00","datePublished":"2023-01-03T12:40:00+09:00","description":"Ownership Ownership이란 Rust만의 유니크한 특성이며, gc없이도 안전하게 메모리를 사용하게 해주는 개념이다. What is Ownership? Ownership은 Rust가 어떻게 memory를 관리할 지 통제하는 규칙들의 set이다. 어떤 언어들은 garbage collection이 주기적으로 더이상 사용하지 않는 메모리들을 관리해주고(Java, JS, Python, GO) 어떤 언어들은 프로그래머가 직접 할당과 해제를 하여 메모리를 관리해야 한다.(C, C++) Rust는 그 외의 방식: compiler가 체크하는 규칙들의 set인 ownership 시스템에 의해 관리된다. 규칙이 위배된다면, compile되지 않는다! The Stack and the Heap 대부분의 언어들은 작업할 때 stack과 heap에 대해 신경쓰지 않아도 된다. 하지만 Rust는 value가 stack or heap 어디에 있는 값인지에 따라 다르게 작동한다. 따라서 여기서 간단하게 짚고 넘어가겠다. Stack Last in, First out (접시쌓기와 같다) data는 known, fixed size fast Heap Allocator가 heap에서 충분한 자리를 찾고 pointer을 return(Allocating: 레스토랑의 자리 안내와 같다) Compile시 unknown size =&gt; Heap slow more work Ownership Rules 다음의 규칙들은 기억하고 예제를 봅시다! Rust에서 각 Value는 owner가 있다. 한 번에 한 owner만 있을 수 있다. owner가 scope를 벗어나면 value는 drop된다. Variable Scope 1 2 3 4 5 6 7 8 fn main() { { // s is not valid here, it’s not yet declared let s = &quot;hello&quot;; // s is valid from this point forward // do stuff with s } // this scope is now over, and s is no longer valid } 이 코드에서 중요한 사실 두가지: scope 안에서 s는 valid하다. scope를 벗어나면 no longer valid하다. The String Type 위의 예제는 string literals로 많은 상황에 맞지 않고, 변형불가능하다. 우리는 String을 사용하여 unknown한 값을 저장할 수 있다. 1 let s = String::from(&quot;hello&quot;); 변형 또한 가능하다. 1 2 3 4 5 let mut s = String::from(&quot;hello&quot;); s.push_str(&quot;, world!&quot;); // push_str() appends a literal to a String println!(&quot;{}&quot;, s); // This will print `hello, world!` 왜 String은 변형 가능하지만 literals는 불가능할까? 이는 두 타입의 메모리 저장 방식이 다르기 때문이다. Memory and Allocation 변형가능하며 늘어날 수 있는 text를 위해서 우리는 heap에 메모리를 할당해야 한다. 이것은 곧 runtime에 allocator에 의해 메모리가 요청되어야 한다. 우리가 해당 String에 관하여 업무가 끝났을 때 이 메모리는 allocator에게 반환 되어야 한다. 을 의미한다. 첫번째 부분은 String::from 을 호출 함으로 해결된다. 두번째 부분이 쉽지않다. GC가 존재하지않으니 우리가 직접 메모리를 관리해야 한다. 너무 빨리 정리하면 invalid해지고, 두번 실행해도 bug이다. 우리는 딱 한번의 allocate와 딱 한번의 free로 매치해야 한다. 변수가 해당 scope 밖으로 나가면 Rust는 ‘drop’이라는 함수를 call하여 메모리를 정리한다. Variables and Data interacting with Move 1 2 let s1 = String::from(&quot;hello&quot;); let s2 = s1; 해당 코드는 s2에 s1의 value를 단순히 복사할 것 같지만 그렇지 않다. 왼쪽의 ptr, len, capacity의 정보들은 stack에 저장되고, 우측의 contents는 heap 메모리에 저장된다. s2에 s1을 할당할 때, contents가 아닌 해당 정보가 담긴 stack의 값만 복사된다.(아래의 사진) 따라서 두개의 포인터가 같은 곳을 바라보고 있게 된다는 뜻인데, 앞서 말했듯 scope를 벗어나면 free 시킬 것이고 그렇다면 두개의 포인터 모두 같은 메모리에 대해 중복으로 처리를 시도하게 된다. 이는 한번 allocate - 한번 free를 위해된다. 이러한 메모리 safety를 위해서 rust는 let s2 = s1 실행시 s1은 더이상 valid하지 않다고 여긴다. 1 2 3 4 let s1 = String::from(&quot;hello&quot;); let s2 = s1; println!(&quot;{}, world!&quot;, s1); // Error! 이는 다른 언어의 shallow copy, deep copy의 원리와 비슷하다. 또한 이 경우 우리는 s1에서 s2로 이동했다고 표현한다. (s1 invalid, scope 벗어날 시 s2는 memory free 실행) Variables and Data interacting with Clone 위와는 달리 heap data까지 deep copy를 하고 싶으면 우리는 Clone을 사용할 수있다. 1 2 3 4 let s1 = String::from(&quot;hello&quot;); let s2 = s1.clone(); println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2); Stack-Only Data: Copy 1 2 3 4 let x = 5; let y = x; println!(&quot;x = {}, y = {}&quot;, x, y); 다음과 같은 integer값은 clone 필요없이 잘 작동한다. integers 같은 값은 정해진 size이며 전체 값이 stack에 저장된다. 따라서 실제값을 copy하는 데에도 굉장히 빠르다. Rust는 ‘Copy’라는 special annotation을 갖고있는데, 만약 type이 Copy를 implements한다면 위 예제의 ‘이동’이 발생하지않고 평범하게 copy되고 할당 후에도 계속 valid하다. Copy를 implements하는 타입 목록은 다음과 같다. All the integer types. The Boolean type All the floating-point types The character type Tuples, if they only contain types that also implement Copy.(둘다 Copy를 implement하는 경우) Ownership and Functions 함수에 값을 전달하는 것도 변수에 초기화 하는 것과 비슷하다. move or copy. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 fn main() { let s = String::from(&quot;hello&quot;); // s comes into scope takes_ownership(s); // s&#39;s value moves into the function... // ... and so is no longer valid here let x = 5; // x comes into scope makes_copy(x); // x would move into the function, // but i32 is Copy, so it&#39;s okay to still // use x afterward } // Here, x goes out of scope, then s. But because s&#39;s value was moved, nothing // special happens. fn takes_ownership(some_string: String) { // some_string comes into scope println!(&quot;{}&quot;, some_string); } // Here, some_string goes out of scope and `drop` is called. The backing // memory is freed. fn makes_copy(some_integer: i32) { // some_integer comes into scope println!(&quot;{}&quot;, some_integer); } // Here, some_integer goes out of scope. Nothing special happens. takes_ownership(s); 이후에 s를 호출하면 compile-time Error! Return Values and Scope 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 fn main() { let s1 = gives_ownership(); // gives_ownership moves its return // value into s1 let s2 = String::from(&quot;hello&quot;); // s2 comes into scope let s3 = takes_and_gives_back(s2); // s2 is moved into // takes_and_gives_back, which also // moves its return value into s3 } // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing // happens. s1 goes out of scope and is dropped. fn gives_ownership() -&gt; String { // gives_ownership will move its // return value into the function // that calls it let some_string = String::from(&quot;yours&quot;); // some_string comes into scope some_string // some_string is returned and // moves out to the calling // function } // This function takes a String and returns one fn takes_and_gives_back(a_string: String) -&gt; String { // a_string comes into // scope a_string // a_string is returned and moves out to the calling function } 함수를 사용하면서 소유권을 갖는 것과 반납하는 것은 매우 성가시다. Rust에서는 이를 위해서 references를 제공한다! Ref: https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html","headline":"ownership of rust(1)","mainEntityOfPage":{"@type":"WebPage","@id":"https://milo-oh-taek.github.io//posts/ownership-of-rust(1)/"},"url":"https://milo-oh-taek.github.io//posts/ownership-of-rust(1)/"}</script><title>ownership of rust(1) | Hyeontaek Oh</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Hyeontaek Oh"><meta name="application-name" content="Hyeontaek Oh"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/dobby.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Hyeontaek Oh</a></div><div class="site-subtitle font-italic">Web Developer</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/github_username" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['oht366','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>ownership of rust(1)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>ownership of rust(1)</h1><div class="post-meta text-muted"><div> By <em> <a href="https://twitter.com/username">Milo</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" date="2023-01-03 12:40:00 +0900" data-toggle="tooltip" data-placement="bottom" title="Tue, Jan 3, 2023, 12:40 PM +0900" >Jan 3, 2023</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1820 words"> <em>10 min</em> read</span></div></div></div><div class="post-content"><h2 id="ownership">Ownership<a href="#ownership" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Ownership이란 Rust만의 유니크한 특성이며, gc없이도 안전하게 메모리를 사용하게 해주는 개념이다.</p><h2 id="what-is-ownership">What is Ownership?<a href="#what-is-ownership" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Ownership은 Rust가 어떻게 memory를 관리할 지 통제하는 규칙들의 set이다.</p><p>어떤 언어들은 garbage collection이 주기적으로 더이상 사용하지 않는 메모리들을 관리해주고(Java, JS, Python, GO) 어떤 언어들은 프로그래머가 직접 할당과 해제를 하여 메모리를 관리해야 한다.(C, C++)</p><p><strong>Rust는 그 외의 방식: compiler가 체크하는 규칙들의 set인 ownership 시스템에 의해 관리된다.</strong></p><blockquote><blockquote><p>규칙이 위배된다면, compile되지 않는다!</p></blockquote></blockquote><h3 id="the-stack-and-the-heap">The Stack and the Heap<a href="#the-stack-and-the-heap" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>대부분의 언어들은 작업할 때 stack과 heap에 대해 신경쓰지 않아도 된다. <br /> 하지만 Rust는 value가 stack or heap 어디에 있는 값인지에 따라 다르게 작동한다. <br /> 따라서 여기서 간단하게 짚고 넘어가겠다.</p><h4 id="stack">Stack<a href="#stack" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>Last in, First out (접시쌓기와 같다)<li>data는 known, fixed size<li>fast</ul><h4 id="heap">Heap<a href="#heap" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>Allocator가 heap에서 충분한 자리를 찾고 pointer을 return(Allocating: 레스토랑의 자리 안내와 같다)<li>Compile시 unknown size =&gt; Heap<li>slow<li>more work</ul><h3 id="ownership-rules">Ownership Rules<a href="#ownership-rules" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>다음의 규칙들은 기억하고 예제를 봅시다!</p><ul><li>Rust에서 각 Value는 owner가 있다.<li>한 번에 한 owner만 있을 수 있다.<li>owner가 scope를 벗어나면 value는 drop된다.</ul><h3 id="variable-scope">Variable Scope<a href="#variable-scope" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>fn main() {
    {                      // s is not valid here, it’s not yet declared
        let s = "hello";   // s is valid from this point forward

        // do stuff with s
    }                      // this scope is now over, and s is no longer valid
}

</pre></table></code></div></div><p>이 코드에서 중요한 사실 두가지:</p><ul><li>scope 안에서 s는 valid하다.<li>scope를 벗어나면 no longer valid하다.</ul><h3 id="the-string-type">The String Type<a href="#the-string-type" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>위의 예제는 string literals로 많은 상황에 맞지 않고, 변형불가능하다. <br /> 우리는 String을 사용하여 unknown한 값을 저장할 수 있다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>let s = String::from("hello");
</pre></table></code></div></div><p>변형 또한 가능하다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>let mut s = String::from("hello");

s.push_str(", world!"); // push_str() appends a literal to a String

println!("{}", s); // This will print `hello, world!`
</pre></table></code></div></div><p>왜 String은 변형 가능하지만 literals는 불가능할까? <br /> 이는 두 타입의 메모리 저장 방식이 다르기 때문이다.</p><h3 id="memory-and-allocation">Memory and Allocation<a href="#memory-and-allocation" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>변형가능하며 늘어날 수 있는 text를 위해서 우리는 heap에 메모리를 할당해야 한다. <br /> 이것은 곧</p><ul><li>runtime에 allocator에 의해 메모리가 요청되어야 한다.<li>우리가 해당 String에 관하여 업무가 끝났을 때 이 메모리는 allocator에게 반환 되어야 한다.</ul><p>을 의미한다.</p><p>첫번째 부분은 String::from 을 호출 함으로 해결된다. <br /> 두번째 부분이 쉽지않다. GC가 존재하지않으니 우리가 직접 메모리를 관리해야 한다. <br /> 너무 빨리 정리하면 invalid해지고, 두번 실행해도 bug이다. <br /> <strong>우리는 딱 한번의 allocate와 딱 한번의 free로 매치해야 한다.</strong></p><p>변수가 해당 scope 밖으로 나가면 Rust는 ‘drop’이라는 함수를 call하여 메모리를 정리한다.</p><h4 id="variables-and-data-interacting-with-move">Variables and Data interacting with Move<a href="#variables-and-data-interacting-with-move" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>let s1 = String::from("hello");
let s2 = s1;
</pre></table></code></div></div><p>해당 코드는 s2에 s1의 value를 단순히 복사할 것 같지만 그렇지 않다. <br /> <img data-src="https://user-images.githubusercontent.com/56327550/210301736-0f644f72-106f-4426-ad62-13b870f0b6a7.svg" alt="trpl04-01" data-proofer-ignore></p><p>왼쪽의 ptr, len, capacity의 정보들은 stack에 저장되고, <br /> 우측의 contents는 heap 메모리에 저장된다.</p><p>s2에 s1을 할당할 때, contents가 아닌 해당 정보가 담긴 stack의 값만 복사된다.(아래의 사진)</p><p><img data-src="https://user-images.githubusercontent.com/56327550/210301989-694fc816-c695-4185-be72-6d6b3c68ce5d.svg" alt="trpl04-02" data-proofer-ignore></p><p>따라서 두개의 포인터가 같은 곳을 바라보고 있게 된다는 뜻인데, <br /> 앞서 말했듯 scope를 벗어나면 free 시킬 것이고 그렇다면 두개의 포인터 모두 <br /> 같은 메모리에 대해 중복으로 처리를 시도하게 된다. 이는 한번 allocate - 한번 free를 위해된다.</p><p>이러한 메모리 safety를 위해서 rust는 let s2 = s1 실행시 s1은 더이상 valid하지 않다고 여긴다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1); // Error!
</pre></table></code></div></div><p>이는 다른 언어의 shallow copy, deep copy의 원리와 비슷하다. <br /> 또한 이 경우 우리는 s1에서 s2로 이동했다고 표현한다.</p><p><img data-src="https://user-images.githubusercontent.com/56327550/210302828-a02f1105-a5f4-48c4-a4f7-e1ea88797988.svg" alt="trpl04-04" data-proofer-ignore> <br /> (s1 invalid, scope 벗어날 시 s2는 memory free 실행)</p><h4 id="variables-and-data-interacting-with-clone">Variables and Data interacting with Clone<a href="#variables-and-data-interacting-with-clone" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>위와는 달리 heap data까지 deep copy를 하고 싶으면 우리는 Clone을 사용할 수있다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
</pre></table></code></div></div><h4 id="stack-only-data-copy">Stack-Only Data: Copy<a href="#stack-only-data-copy" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
</pre></table></code></div></div><p>다음과 같은 integer값은 clone 필요없이 잘 작동한다. <br /> integers 같은 값은 정해진 size이며 전체 값이 stack에 저장된다. <br /> 따라서 실제값을 copy하는 데에도 굉장히 빠르다.</p><p>Rust는 ‘Copy’라는 special annotation을 갖고있는데, 만약 type이 Copy를 implements한다면 <br /> 위 예제의 ‘이동’이 발생하지않고 평범하게 copy되고 할당 후에도 계속 valid하다.</p><p>Copy를 implements하는 타입 목록은 다음과 같다.</p><ul><li>All the integer types.<li>The Boolean type<li>All the floating-point types<li>The character type<li>Tuples, if they only contain types that also implement Copy.(둘다 Copy를 implement하는 경우)</ul><h3 id="ownership-and-functions">Ownership and Functions<a href="#ownership-and-functions" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>함수에 값을 전달하는 것도 변수에 초기화 하는 것과 비슷하다. <br /> move or copy.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre>fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it's okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
</pre></table></code></div></div><p>takes_ownership(s); 이후에 s를 호출하면 compile-time Error!</p><h3 id="return-values-and-scope">Return Values and Scope<a href="#return-values-and-scope" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre>fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing
  // happens. s1 goes out of scope and is dropped.

fn gives_ownership() -&gt; String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from("yours"); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// This function takes a String and returns one
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
</pre></table></code></div></div><p>함수를 사용하면서 소유권을 갖는 것과 반납하는 것은 매우 성가시다. <br /> Rust에서는 이를 위해서 references를 제공한다!</p><p>Ref: <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/rust/'>RUST</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/rust/" class="post-tag no-text-decoration" >rust</a> <a href="/tags/ownership/" class="post-tag no-text-decoration" >ownership</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://www.linkedin.com/in/hyeontaek-oh-b27709171/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recent Update</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/modern-js-tutorial-class/">modern js tutorial class</a><li><a href="/posts/modern-js-tutorial-promise-api/">js promise api</a><li><a href="/posts/Docker-command/">Docker command</a><li><a href="/posts/modern-js-tutorial-bind/">modern js tutorial bind</a><li><a href="/posts/modern-js-tutorial-scheduling-call/">modern js tutorial scheduling call</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/javascript/">javascript</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/react/">react</a> <a class="post-tag" href="/tags/typescript/">typescript</a> <a class="post-tag" href="/tags/aws/">aws</a> <a class="post-tag" href="/tags/ubuntu/">ubuntu</a> <a class="post-tag" href="/tags/cicd/">cicd</a> <a class="post-tag" href="/tags/es6/">es6</a> <a class="post-tag" href="/tags/port/">port</a> <a class="post-tag" href="/tags/access/">access</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/springboot-dto-validation-groups/"><div class="card-body"> <em class="timeago small" date="2025-09-26 07:47:00 +0900" >Sep 26</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>springboot dto groups - validation created일때만 적용하기</h3><div class="text-muted small"><p> DTO를 Create, Update 공용으로 사용할때, Create일때만 validation 적용하기 Interface file 생성 CreateValidationGroup이라는 빈 인터페이스를 만들어준다. 1 2 3 com.demo.microservice ㄴ validators ㄴ CreateValidationGroup DTO group...</p></div></div></a></div><div class="card"> <a href="/posts/springboot-ec2-ci-cd/"><div class="card-body"> <em class="timeago small" date="2025-09-23 04:40:00 +0900" >Sep 23</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>springboot github action docker ec2 cicd</h3><div class="text-muted small"><p> Dockerfile 1 2 3 4 5 6 7 8 9 FROM openjdk:23 WORKDIR /app COPY target/demo-*.jar app.jar EXPOSE 8080 ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;app.jar&quot;] main.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 1...</p></div></div></a></div><div class="card"> <a href="/posts/kafka-basic/"><div class="card-body"> <em class="timeago small" date="2025-09-16 04:40:00 +0900" >Sep 16</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>kafka basic</h3><div class="text-muted small"><p> Kafka - Event-Driven Architectures High Throughput Fault Tolerance Scalability Real-Time Processing Topic Where all similar events related to a service can be stored. Message Categ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/atomicdesign/" class="btn btn-outline-primary" prompt="Older"><p>atomic design 아토믹 디자인</p></a> <a href="/posts/gitlab-aws-s3-ci-cd/" class="btn btn-outline-primary" prompt="Newer"><p>react gitlab aws s3 ci/cd</p></a></div><script src="https://utteranc.es/client.js" repo="Milo-Oh-taek/Milo-Oh-taek.github.io" issue-term="pathname" crossorigin="anonymous" async> </script> <script type="text/javascript"> $(function() { const origin = "https://utteranc.es"; const iframe = "iframe.utterances-frame"; const lightTheme = "github-light"; const darkTheme = "github-dark"; let initTheme = lightTheme; if ($("html[mode=dark]").length > 0 || ($("html[mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } addEventListener("message", (event) => { let theme; /* credit to <https://github.com/utterance/utterances/issues/170#issuecomment-594036347> */ if (event.origin === origin) { /* page initial */ theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); } else { return; } const message = { type: "set-theme", theme: theme }; const utterances = document.querySelector(iframe).contentWindow; utterances.postMessage(message, origin); }); }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/username">Milo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/javascript/">javascript</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/react/">react</a> <a class="post-tag" href="/tags/typescript/">typescript</a> <a class="post-tag" href="/tags/aws/">aws</a> <a class="post-tag" href="/tags/ubuntu/">ubuntu</a> <a class="post-tag" href="/tags/cicd/">cicd</a> <a class="post-tag" href="/tags/es6/">es6</a> <a class="post-tag" href="/tags/port/">port</a> <a class="post-tag" href="/tags/access/">access</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-LQRW5WT0BM"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-LQRW5WT0BM'); }); </script>
